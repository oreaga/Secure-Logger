<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;  charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.76C-CCK-MCD  [en] (X11;  U;  SunOS 5.8 sun4u) [Netscape]">
   <title>Java Cryptography Extension 1.2.2</title>
</head>
<body bgcolor="#FFFFFF">

<hr>
<center>
<h1>
Java<sup><font size=-2>TM</font></sup> Cryptography Extension 1.2.2</h1></center>

<center>
<h1>
API Specification &amp; Reference</h1></center>

<hr>
<dl>
<dd>
<b><font size=+2><a href="#Introduction">Introduction</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#Introduction"></a></font></b></dd>

<dd>
<b><font size=+2><a href="#WhatsNew122">What's New in JCE 1.2.2</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#WhatsNew121">What's New in JCE 1.2.1</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#Concepts">Cryptographic Concepts</a></font></b></dd>

<dl>
<dd>
<b><a href="#EncrDecr">Encryption and Decryption</a></b></dd>

<dd>
<b><a href="#PBE">Password-Based Encryption</a></b></dd>

<dd>
<b><a href="#Cipher">Cipher</a></b></dd>

<dd>
<b><a href="#KeyAgree">Key Agreement</a></b></dd>

<dd>
<b><a href="#MAC">Message Authentication Code</a></b></dd>
</dl>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#CoreClasses">Core Classes</a></font></b></dd>

<dl>
<dd>
<b><a href="#CipherClass">The Cipher Class</a></b></dd>

<dd>
<b><a href="#CipherStream">The Cipher Stream Classes</a></b></dd>

<dl>
<dd>
<b><a href="#CipherInput">The CipherInputStream Class</a></b></dd>

<dd>
<b><a href="#CipherOutput">The CipherOutputStream Class</a></b></dd>
</dl>

<dd>
<b><a href="#KeyGenerator">The KeyGenerator Class</a></b></dd>

<dd>
<b><a href="#SecretFactory">The SecretKeyFactory Class</a></b></dd>

<dd>
<b><a href="#SealedObject">The SealedObject Class</a></b></dd>

<dd>
<b><a href="#KeyAgreement">The KeyAgreement Class</a></b></dd>

<dd>
<b><a href="#Mac">The Mac Class</a></b></dd>
</dl>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#ExemptApps">How to Make Applications "Exempt"
from Cryptographic Restrictions</a></font></b><br>&nbsp;</dd>


<dd>
<b><font size=+2><a href="#InstallProvider">Installing Providers for JCE
1.2.2</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#JceKeystore">JCE Keystore</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#Examples">Code Examples</a></font></b></dd>

<dl>
<dd>
<b><a href="#SimpleEncrEx">Using Encryption</a></b></dd>

<dd>
<b><a href="#PBEEx">Using Password-Based Encryption</a></b></dd>

<dd>
<b><a href="#KeyAgreeEx">Using Key Agreement</a></b></dd>
</dl>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#AppA">Appendix A: Standard Names</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#AppB">Appendix B: SunJCE Default Keysizes</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#AppC">Appendix C: SunJCE Keysize Restrictions</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#AppD">Appendix D: Jurisdiction Policy File Format</a></font></b></dd>

<br>&nbsp;
<dd>
<b><font size=+2><a href="#AppE">Appendix E: Sample Programs</a></font></b></dd>

<dl>
<dd>
<b><a href="#DH2Ex">Diffie-Hellman Key Exchange between 2 Parties</a></b></dd>

<dd>
<b><a href="#DH3Ex">Diffie-Hellman Key Exchange between 3 Parties</a></b></dd>

<dd>
<b><a href="#BlowKeyEx">Blowfish Example</a></b></dd>

<dd>
<b><a href="#HmacEx">HMAC-MD5 Example</a></b></dd>
</dl>
</dl>

<hr>
<h1>
<a NAME="Introduction"></a>Introduction</h1>

<blockquote>This document is intended as a companion to the <a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/CryptoSpec.html">Java<sup><font size=-2>TM</font></sup>
Cryptography Architecture (JCA) API Specification &amp; Reference</a>.
References to chapters not present in this document are to chapters in
the JCA Specification.
<p>The Java<sup><font size=-2>TM</font></sup> Cryptography Extension (JCE)
1.2.2 provides a framework and implementations for encryption, key generation
and key agreement, and Message Authentication Code (MAC) algorithms. Support
for encryption includes symmetric, asymmetric, block, and stream ciphers.
The software also supports secure streams and sealed objects.
<p>JCE 1.2.2 has a provider-based architecture. Providers signed by a trusted
entity can be plugged into the JCE 1.2.2 framework, and new algorithms
can be added seamlessly.
<p>JCE 1.2.2 supplements the Java<sup><font size=-2>TM</font></sup> 2 SDK,
Standard Edition, v 1.2 (J2SDK), formerly known as JDK<sup><font size=-2>TM</font></sup>
version 1.2, which already includes interfaces and implementations of message
digests and digital signatures. JCE 1.2.2 is provided as an optional package
(formerly known as an "extension") to the Java<sup><font size=-2>TM</font></sup>
2 platform.
<p>JCE 1.2.2 is based on the same
<a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/CryptoSpec.html#Design">design
principles</a> found elsewhere in the JCA: implementation independence
and, whenever possible, algorithm independence. It uses the same <a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/CryptoSpec.html#ProviderArch">"provider"</a>
architecture.
<p>The JCE 1.2.2 API covers:
<ul>
<li>
Symmetric bulk encryption, such as DES, RC2, and IDEA</li>

<P>
<li>
Symmetric stream encryption, such as RC4</li>

<P>
<li>
Asymmetric encryption, such as RSA</li>

<P>
<li>
Password-based encryption (PBE)</li>

<P>
<li>
Key Agreement</li>

<P>
<li>
Message Authentication Codes (MAC)</li>
</ul>
The JCE 1.2.2 release comes standard with a provider named "SunJCE", which
must be <a href="#InstallProvider">installed</a> and which supplies the
following cryptographic services:
<ul>
<li>
An implementation of the DES (FIPS PUB 46-1), Triple DES, and Blowfish
encryption algorithms in the Electronic Code Book (ECB), Cipher Block Chaining
(CBC), Cipher Feedback (CFB), Output Feedback (OFB), and Propagating Cipher
Block Chaining (PCBC) modes. (Note: Throughout this document, the terms
"Triple DES" and "DES-EDE" will be used interchangeably.)</li>

<P>
<li>
Key generators for generating keys suitable for the DES, Triple DES, Blowfish,
HMAC-MD5, and HMAC-SHA1 algorithms.</li>

<P>
<li>
An implementation of the MD5 with DES-CBC password-based encryption (PBE)
algorithm defined in PKCS #5.</li>

<P>
<li>
"Secret-key factories" providing bi-directional conversions between opaque
DES, Triple DES and PBE key objects and transparent representations of
their underlying key material.</li>

<P>
<li>
An implementation of the Diffie-Hellman key agreement algorithm between
two or more parties.</li>

<P>
<li>
A Diffie-Hellman key pair generator for generating a pair of public and
private values suitable for the Diffie-Hellman algorithm.</li>

<P>
<li>
A Diffie-Hellman algorithm parameter generator.</li>

<P>
<li>
A Diffie-Hellman "key factory" providing bi-directional conversions between
opaque Diffie-Hellman key objects and transparent representations of their
underlying key material.</li>

<P>
<li>
Algorithm parameter managers for Diffie-Hellman, DES, Triple DES, Blowfish,
and PBE parameters.</li>

<P>
<li>
An implementation of the HMAC-MD5 and HMAC-SHA1 keyed-hashing algorithms
defined in RFC 2104.</li>

<P>
<li>
An implementation of the padding scheme described in PKCS#5.</li>

<P>
<li>
A keystore implementation for the proprietary keystore type named "JCEKS".</li>
</ul>

<h3>
<a NAME="Terminology"></a>A Note on Terminology</h3>

<blockquote>The JCE 1.2.2 release includes two software components:
<ul>
<li>
the framework that defines and supports cryptographic services that providers
can supply implementations for. This framework includes everything in the
<tt>javax.crypto</tt>
package.</li>

<P>
<li>
a provider named "SunJCE"</li>
</ul>
Throughout this document, the term "JCE 1.2.2" refers to the JCE 1.2.2
framework. If the full release is mentioned, it will be referred to as
"the JCE 1.2.2 release."</blockquote>
</blockquote>

<h1>
<a NAME="WhatsNew122"></a>What's New in JCE 1.2.2</h1>

<blockquote>JCE 1.2.2 is primarily a bug-fix release. Here is a summary
of bugs fixed in JCE 1.2.2:
<blockquote>
<li>
JCE has changed its signed jar verification routine to accept signed jars
with legitimate certificates even if the certificate has expired. 
As a result, when JCE's signing certificate expires, J2SE 1.2 and 1.3 
users can continue to use JCE 1.2.2. These users are not required to migrate 
to J2SE 1.4  before J2SE 1.2 and 1.3 are End of Life'd (no longer supported or updated).
</li>

<br>&nbsp;
<li>
The two jurisdiction policy files and the JCE framework jar files should be signed
by the same entity. This constraint is now enforced. If these files are
not signed by the same entity, a <code>SecurityException</code> 
will be thrown stating that "Signer restraint check failed".</li>

<br>&nbsp;
<li>
Depending on how providers register their implementations, provider lookup
may return an implementation from a less-preferred provider. This error has 
been fixed so that the provider lookup decision is solely based on the preference
orders.</li>

<br>&nbsp;
<li>
When verifying providers, JCE failed to correctly verify the 
provider certificate chain.</li>

<br>&nbsp;
<li>
JCE used to read in the two jurisdiction policy files using the default encoding
scheme. Since the two jurisdiction policy files are always encoded in UTF-8,
JCE has been modified to use UTF-8 regardless of the default.</li>

<br>&nbsp;
<li>
<code>Cipher.update(byte[] input, int offset, int len)</code> threw a 
<cod&nbsp;e>NullPointerException</code> incorrectly when the input data 
is too short to result in a new block. </li>

<br>&nbsp;
<li>
There were problems in JCE's double-encryption checking routine which caused
<code>SecurityException</code> to be thrown on consecutive encryptions of data with
all 0 (zero) values. </li>

<br>&nbsp;
<li>
The <code>HmacSHA1</code> and <code>HmacMD5</code> implementation 
in "SunJCE" provider did not produce the correct MAC result if 
the key length is between 33 and 63 bytes.</li>

<br>&nbsp;
<li>
The <code>DESedeParameters</code> implementation in "SunJCE" provider 
threw an <code>ArrayIndexOutOfBoundsException</code>
if an 0-length byte array is specified in its <code>init()</code> 
calls. Now, an <code>IOException</code>
is thrown in place of <code>ArrayIndexOutOfBoundsException</code> 
as specified in the API documentation.</li>

<br>&nbsp;
<li>
Clarified the API documenation for <code>javax.crypto.Cipher</code> and 
<code>javax.crypto.CipherSpi</code>.</li>

<br>&nbsp;
<li>
Fixed API documentation errors.</li>
</blockquote>
</blockquote>

<h1>
<a NAME="WhatsNew121"></a>What's New in JCE 1.2.1</h1>

<blockquote>Here are the differences between JCE 1.2 and JCE 1.2.1:
<ul>
<li>
<a href="#Exportability">Exportability</a></li>

<br>&nbsp;
<li>
<a href="#Wrap">Key Wrapping for Secure Transport</a></li>

<br>&nbsp;
<li>
<a href="#CipherInit">Additional Cipher Initialization Methods</a></li>

<br>&nbsp;
<li>
<a href="#NewExemptionMech">Exemption Mechanisms</a></li>
</ul>

<h2>
<a NAME="Exportability"></a>Exportability</h2>

<blockquote>The primary difference between JCE 1.2 and JCE 1.2.1 is that
the JCE 1.2.1 framework and provider cryptography implementations are now
exportable outside the U.S. and Canada if certain conditions are satisfied.
<p>Export control restrictions by the U.S. Commerce Department prohibit
frameworks for encryption services from being exported, unless appropriate
mechanisms have been implemented to ensure that only qualified providers
can be plugged into the framework. (Qualified providers include those approved
for export and those certified for domestic use only. Qualified providers
are signed by a trusted entity.)
<p>The JCE 1.2.1 framework contains such mechanisms and is thus now exportable.
It is transparent to application developers how providers are authenticated,
and only qualified providers can be plugged into JCE 1.2.1.
<p>The JCE 1.2.1 framework also includes an ability to enforce restrictions
regarding the cryptographic algorithms and maximum cryptographic strength
available to applets/applications in different jurisdiction contexts (locations).
Any such restrictions are to be specified in "jurisdiction policy files"
that are downloaded along with the JCE 1.2.1 software. The U.S. government
has relaxed export restrictions.
<b>The JCE 1.2.1 software from Sun Microsystems
now has a single distribution for both domestic and global users. The bundled
jurisdiction policy files contain <i>no</i> restrictions on cryptographic
strengths.</b> This is appropriate for most countries.
<p>A few countries' own governments may mandate restrictions. Other framework
vendors could create download bundles that include jurisdiction policy
files that specify cryptographic restrictions mandated by other countries.
Users in those countries could download an appropriate bundle, and the
JCE framework will enforce the specified restrictions.</blockquote>

<h2>
<a NAME="Wrap"></a>Key Wrapping for Secure Transport</h2>

<blockquote>Another difference between JCE 1.2 and JCE 1.2.1 is the addition
of
<tt>wrap</tt> and <tt>unwrap</tt> methods in the Cipher class. Providers
can implement these methods for "wrapping" and "unwrapping" keys.
<p>"Wrapping" a key enables secure transfer of the key from one place to
another.
<p>Further information about wrapping and unwrapping keys is provided in
the <a href="#WrapUnwrap">Wrapping and Unwrapping Keys</a> section.</blockquote>

<h2>
<a NAME="CipherInit"></a>Additional Cipher Initialization Methods</h2>

<blockquote>Two new Cipher initialization methods have been added:
<blockquote>
<pre>&nbsp;&nbsp;&nbsp; public void init(int opmode, Certificate certificate)
&nbsp;&nbsp;&nbsp; public void init(int opmode, Certificate certificate,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecureRandom random)</pre>
</blockquote>
These enable a Cipher to be initialized from a key within a certificate
(rather than from a key directly).
<p>Further information about these and other Cipher initialization methods
is provided in the <a href="#InitaCipher">Initializing a Cipher Object</a>
section.</blockquote>

<h2>
<a NAME="NewExemptionMech"></a>Exemption Mechanisms</h2>

<blockquote>JCE 1.2.1 defines an exemption mechanism API for cryptographic
exemption mechanisms, including key recovery, key weakening, key escrow,
or any other (custom) exemption mechanism.
<p>An app (applet or application) utilizing an exemption mechanism implemented
by a provider may allow that app to use cryptography of potentially greater
strength than that allowed by default. However, please note that cryptographic
restrictions are no longer required for most countries, and thus exemption
mechanisms may only be useful in those few countries whose governments
mandate restrictions.
<p>For more information about the requirements for apps that utilize exemption
mechanisms, see
<a href="#ExemptApps">How to Make Applications "Exempt"
from Cryptographic Restrictions</a>.</blockquote>
</blockquote>

<h1>
<a NAME="Concepts"></a>Cryptographic Concepts</h1>

<blockquote>This section provides a high-level description of the concepts
implemented by the API, and the exact meaning of the technical terms used
in the API specification.
<dl>
<dt>
<a NAME="EncrDecr"></a><B>Encryption and Decryption</B></dt>
<dd>
Encryption is the process of taking data (called <i>cleartext</i>) and
a short string (a <i>key</i>), and producing data (<i>ciphertext</i>) meaningless
to a third-party who does not know the key. Decryption is the inverse process:
that of taking ciphertext and a short key string, and producing cleartext.
</dd>
<P>
<dt>
<a NAME="PBE"></a><B>Password-Based Encryption</B></dt>
<dd>
Password-Based Encryption (PBE) derives an encryption key from a password.
In order to make the task of getting from password to key very time-consuming
for an attacker, most PBE implementations will mix in a random number,
known as a <i>salt</i>, to create the key.
</dd>
<P>
<dt>
<a NAME="Cipher"></a><B>Cipher</B></dt>
<dd>
Encryption and decryption are done using a cipher. A cipher is an object
capable of carrying out encryption and decryption according to an encryption
scheme (algorithm).

</dd>
<P>
<dt>
<a NAME="KeyAgree"></a><B>Key Agreement</B></dt>
<dd>
Key agreement is a protocol by which 2 or more parties can establish the
same cryptographic keys, without having to exchange any secret information.
</dd>
<P>
<dt>
<a NAME="MAC"></a><B>Message Authentication Code</B></dt>
<dd>
A Message Authentication Code (MAC) provides a way to check the integrity
of information transmitted over or stored in an unreliable medium, based
on a secret key. Typically, message authentication codes are used between
two parties that share a secret key in order to validate information transmitted
between these parties.
<p>A MAC mechanism that is based on cryptographic hash functions is referred
to as HMAC. HMAC can be used with any cryptographic hash function, e.g.,
MD5 or SHA-1, in combination with a secret shared key. HMAC is specified
in RFC 2104.
</dl>

</blockquote>

<h1>
<a NAME="CoreClasses"></a>Core Classes</h1>

<blockquote>
<ul>
<h2>
<a NAME="CipherClass"></a>The Cipher Class</h2>

<blockquote>The Cipher class provides the functionality of a cryptographic
cipher used for encryption and decryption. It forms the core of the JCE
1.2.2 framework.
<h4>
Creating a Cipher Object</h4>

<blockquote>Like other engine classes in the API, Cipher objects are created
using the <tt>getInstance</tt> factory methods of the Cipher class. A factory
method is a static method that returns an instance of a class, in this
case, an instance of <tt>Cipher</tt>, which implements a requested <i>transformation</i>.
<p>To create a Cipher object, you must specify the transformation name.
You may also specify which provider you want to supply the implementation
of the requested transformation:
<pre>&nbsp;&nbsp;&nbsp; public static Cipher getInstance(String transformation);

&nbsp;&nbsp;&nbsp; public static Cipher getInstance(String transformation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String provider);</pre>
If just a transformation name is specified, the system will determine if
there is an implementation of the requested transformation available in
the environment, and if there is more than one, if there is a preferred
one.
<p>If both a transformation name and a package provider are specified,
the system will determine if there is an implementation of the requested
transformation in the package requested, and throw an exception if there
is not.
<p><a NAME="trans"></a>A transformation is a string that describes the
operation (or set of operations) to be performed on the given input, to
produce some output. A transformation always includes the name of a cryptographic
algorithm (e.g., <tt>DES</tt>), and may be followed by a mode and padding
scheme.
<p>A transformation is of the form:

<ul>
<li>
"<i>algorithm/mode/padding</i>" or</li>

<li>
"<i>algorithm</i>"</li>
</ul>
<P>
For example, the following are valid transformations:
<blockquote>
<pre>
"<i>DES/CBC/PKCS5Padding</i>"
"<i>DES</i>"
</pre>
</blockquote>

If no mode or padding have been specified, provider-specific default values
for the mode and padding scheme are used. For example, the SunJCE provider
uses <tt>ECB</tt> as the default mode, and
<tt>PKCS5Padding</tt> as the
default padding scheme for
<tt>DES</tt>, <tt>DES-EDE</tt> and <tt>Blowfish</tt>
ciphers. This means that in the case of the SunJCE provider,
<pre>&nbsp;&nbsp;&nbsp; Cipher c1 = Cipher.getInstance("<i>DES/ECB/PKCS5Padding</i>");</pre>
and
<pre>&nbsp;&nbsp;&nbsp; Cipher c1 = Cipher.getInstance("<i>DES</i>");</pre>
are equivalent statements.
<p>When requesting a block cipher in stream cipher mode (e.g.,
<tt>DES</tt>
in <tt>CFB</tt> or <tt>OFB</tt> mode), you may optionally specify the number
of bits to be processed at a time, by appending this number to the mode
name as shown in the "<i>DES/CFB8/NoPadding</i>" and "<i>DES/OFB32/PKCS5Padding</i>"
transformations. If no such number is specified, a provider-specific default
is used. (For example, the SunJCE provider uses a default of 64 bits.)
<p><a href="#AppA">Appendix A</a> of this document contains a list of standard
names that can be used to specify the algorithm name, mode, and padding
scheme components of a transformation.
<p>The objects returned by factory methods are uninitialized, and must
be initialized before they become usable.</blockquote>

<h4>
<a NAME="InitaCipher"></a>Initializing a Cipher Object</h4>

<blockquote>A Cipher object obtained via <tt>getInstance</tt> must be initialized
for one of four modes, which are defined as final integer constants in
the <tt>Cipher</tt> class. The modes can be referenced by their symbolic
names, which are shown below along with a description of the purpose of
each mode:

<ul>
<li>
ENCRYPT_MODE</li>

<blockquote>Encryption of data.</blockquote>

<li>
DECRYPT_MODE</li>

<blockquote>Decryption of data.</blockquote>

<li>
WRAP_MODE</li>

<blockquote>Wrapping a Key into bytes so that the key can be securely transported.</blockquote>

<li>
UNWRAP_MODE</li>

<blockquote>Unwrapping of a previously wrapped key into a <tt>java.security.Key</tt>
object.</blockquote>
</ul>
Each of the Cipher initialization methods takes a mode parameter (<tt>opmode</tt>),
and initializes the Cipher object for that mode. Other parameters include
the key (<tt>key</tt>) or certificate containing the key (<tt>certificate</tt>),
algorithm parameters (<tt>params</tt>), and a source of randomness (<tt>random</tt>).
<p>To initialize a Cipher object, call one of the following <tt>init</tt>
methods:
<pre>&nbsp;&nbsp;&nbsp; public void init(int opmode, Key key);

&nbsp;&nbsp;&nbsp; public void init(int opmode, Certificate certificate)

&nbsp;&nbsp;&nbsp; public void init(int opmode, Key key,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecureRandom random);

&nbsp;&nbsp;&nbsp; public void init(int opmode, Certificate certificate,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecureRandom random)

&nbsp;&nbsp;&nbsp; public void init(int opmode, Key key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameterSpec params);

&nbsp;&nbsp;&nbsp; public void init(int opmode, Key key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameterSpec params,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecureRandom random);

&nbsp;&nbsp;&nbsp; public void init(int opmode, Key key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameters params)

&nbsp;&nbsp;&nbsp; public void init(int opmode, Key key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameters params,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecureRandom random)</pre>
If a Cipher object that requires parameters (e.g., an initialization vector)
is initialized for encryption, and no parameters are supplied to the <tt>init</tt>
method, the underlying cipher implementation is supposed to supply the
required parameters itself, either by generating random parameters or by
using a default, provider-specific set of parameters.
<p>However, if a Cipher object that requires parameters is initialized
for decryption, and no parameters are supplied to the
<tt>init</tt> method,
an <tt>InvalidKeyException</tt> or
<tt>InvalidAlgorithmParameterException</tt>
exception will be raised, depending on the <tt>init</tt> method that was
used.
<p>See the section about <a href="#ManagingParameters">Managing Algorithm
Parameters</a> for more details.
<p>The same parameters that were used for encryption must be used for decryption.
<p>Note that when a Cipher object is initialized, it loses all previously-acquired
state. In other words, initializing a Cipher is equivalent to creating
a new instance of that Cipher, and initializing it. For example, if a Cipher
is first initialized for decryption with a given key, and then initialized
for encryption, it will lose any state acquired while in decryption mode.</blockquote>

<h4>
<a NAME="EncrDecr"></a>Encrypting and Decrypting Data</h4>

<blockquote>Data can be encrypted or decrypted in one step (<i>single-part
operation</i>) or in multiple steps (<i>multiple-part operation</i>). A
multiple-part operation is useful if you do not know in advance how long
the data is going to be, or if the data is too long to be stored in memory
all at once.
<p>To encrypt or decrypt data in a single step, call one of the
<tt>doFinal</tt>
methods:
<pre>&nbsp;&nbsp;&nbsp; public byte[] doFinal(byte[] input);

&nbsp;&nbsp;&nbsp; public byte[] doFinal(byte[] input, int inputOffset,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int inputLen);

&nbsp;&nbsp;&nbsp; public int doFinal(byte[] input, int inputOffset,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int inputLen, byte[] output);

&nbsp;&nbsp;&nbsp; public int doFinal(byte[] input, int inputOffset,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int inputLen, byte[] output, int outputOffset)</pre>
To encrypt or decrypt data in multiple steps, call one of the
<tt>update</tt>
methods:
<pre>&nbsp;&nbsp;&nbsp; public byte[] update(byte[] input);

&nbsp;&nbsp;&nbsp; public byte[] update(byte[] input, int inputOffset, int inputLen);

&nbsp;&nbsp;&nbsp; public int update(byte[] input, int inputOffset, int inputLen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] output);

&nbsp;&nbsp;&nbsp; public int update(byte[] input, int inputOffset, int inputLen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] output, int outputOffset)</pre>
A multiple-part operation must be terminated by one of the above
<tt>doFinal</tt>
methods (if there is still some input data left for the last step), or
by one of the following <tt>doFinal</tt> methods (if there is no input
data left for the last step):
<pre>&nbsp;&nbsp;&nbsp; public byte[] doFinal();

&nbsp;&nbsp;&nbsp; public int doFinal(byte[] output, int outputOffset);</pre>
All the <tt>doFinal</tt> methods take care of any necessary padding (or
unpadding), if padding (or unpadding) was requested as part of the specified
transformation.
<p>A call to <tt>doFinal</tt> resets the Cipher object to the state it
was in when initialized via a call to
<tt>init</tt>. That is, the Cipher
object is reset and available to encrypt or decrypt (depending on the operation
mode that was specified in the call to <tt>init</tt>) more data.</blockquote>

<h4>
<a NAME="WrapUnwrap"></a>Wrapping and Unwrapping Keys</h4>

<blockquote>Wrapping a key enables secure transfer of the key from one
place to another.
<p>The <tt>wrap/unwrap</tt> API makes it more convenient to write code
since it works with key objects directly. These methods also enable the
possibility of secure transfer of hardware-based keys.
<p>To <b>wrap</b> a Key, first initialize the Cipher object for WRAP_MODE,
and then call the following:
<pre>&nbsp;&nbsp;&nbsp; public final byte[] wrap(Key key);</pre>
If you are supplying the wrapped key bytes (the result of calling <tt>wrap</tt>)
to someone else who will unwrap them, be sure to also send additional information
the recipient will need in order to do the <tt>unwrap</tt>:


<ol>
<li>
the name of the key algorithm, and</li>

<P>
<li>
the type of the wrapped key (one of <tt>Cipher.SECRET_KEY</tt>, <tt>Cipher.PRIVATE_KEY</tt>,
or
<tt>Cipher.PUBLIC_KEY</tt>).</li>
</ol>
The key algorithm name can be determined by calling the
<tt>getAlgorithm</tt>
method from the Key interface:
<pre>&nbsp;&nbsp;&nbsp; public String getAlgorithm();</pre>
To <b>unwrap</b> the bytes returned by a previous call to
<tt>wrap</tt>,
first initialize a Cipher object for UNWRAP_MODE, then call the following:
<pre>&nbsp;&nbsp;&nbsp; public final Key unwrap(byte[] wrappedKey,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String wrappedKeyAlgorithm,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int wrappedKeyType));</pre>
Here, <tt>wrappedKey</tt> is the bytes returned from the previous call
to wrap, <tt>wrappedKeyAlgorithm</tt> is the algorithm associated with
the wrapped key, and <tt>wrappedKeyType</tt> is the type of the wrapped
key. This must be one of
<tt>Cipher.SECRET_KEY</tt>, <tt>Cipher.PRIVATE_KEY</tt>,
or
<tt>Cipher.PUBLIC_KEY</tt>.</blockquote>

<h4>
<a NAME="ManagingParameters"></a>Managing Algorithm Parameters</h4>

<blockquote>The parameters being used by the underlying Cipher implementation,
which were either explicitly passed to the <tt>init</tt> method by the
application or generated by the underlying implementation itself, can be
retrieved from the Cipher object by calling its
<tt>getParameters</tt>
method, which returns the parameters as a
<tt>java.security.AlgorithmParameters</tt>
object (or
<tt>null</tt> if no parameters are being used). If the parameter
is an initialization vector (IV), it can also be retrieved by calling the
<tt>getIV</tt>
method.
<p>In the following example, a Cipher object implementing password-based
encryption is initialized with just a key and no parameters. However, the
selected algorithm for password-based encryption requires two parameters
- a <i>salt</i> and an <i>iteration count</i>. Those will be generated
by the underlying algorithm implementation itself. The application can
retrieve the generated parameters from the Cipher object as follows:
<pre>&nbsp;&nbsp;&nbsp; import javax.crypto.*;
&nbsp;&nbsp;&nbsp; import java.security.AlgorithmParameters;

&nbsp;&nbsp;&nbsp; // get cipher object for password-based encryption
&nbsp;&nbsp;&nbsp; Cipher c = Cipher.getInstance("PBEWithMD5AndDES");

&nbsp;&nbsp;&nbsp; // initialize cipher for encryption, without supplying
&nbsp;&nbsp;&nbsp; // any parameters. Here, "myKey" is assumed to refer&nbsp;
&nbsp;&nbsp;&nbsp; // to an already-generated key.
&nbsp;&nbsp;&nbsp; c.init(Cipher.ENCRYPT_MODE, myKey);
&nbsp;
&nbsp;&nbsp;&nbsp; // encrypt some data and store away ciphertext
&nbsp;&nbsp;&nbsp; // for later decryption
&nbsp;&nbsp;&nbsp; byte[] cipherText = c.doFinal("This is just an example".getBytes());

&nbsp;&nbsp;&nbsp; // retrieve parameters generated by underlying cipher
&nbsp;&nbsp;&nbsp; // implementation
&nbsp;&nbsp;&nbsp; AlgorithmParameters algParams = c.getParameters();

&nbsp;&nbsp;&nbsp; // get parameter encoding and store it away
&nbsp;&nbsp;&nbsp; byte[] encodedAlgParams = algParams.getEncoded();</pre>
The same parameters that were used for encryption must be used for decryption.
They can be instantiated from their encoding and used to initialize the
corresponding Cipher object for decryption, as follows:
<pre>&nbsp;&nbsp;&nbsp; import javax.crypto.*;
&nbsp;&nbsp;&nbsp; import java.security.AlgorithmParameters;

&nbsp;&nbsp;&nbsp; // get parameter object for password-based encryption
&nbsp;&nbsp;&nbsp; AlgorithmParameters algParams;
&nbsp;&nbsp;&nbsp; algParams =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameters.getInstance("PBEWithMD5AndDES");

&nbsp;&nbsp;&nbsp; // initialize with parameter encoding from above
&nbsp;&nbsp;&nbsp; algParams.init(encodedAlgParams);

&nbsp;&nbsp;&nbsp; // get cipher object for password-based encryption
&nbsp;&nbsp;&nbsp; Cipher c = Cipher.getInstance("PBEWithMD5AndDES");

&nbsp;&nbsp;&nbsp; // initialize cipher for decryption, using one of the&nbsp;
&nbsp;&nbsp;&nbsp; // init() methods that takes an AlgorithmParameters&nbsp;
&nbsp;&nbsp;&nbsp; // object, and pass it the algParams object from above
&nbsp;&nbsp;&nbsp; c.init(Cipher.DECRYPT_MODE, myKey, algParams);</pre>
If you did not specify any parameters when you initialized a Cipher object,
and you are not sure whether or not the underlying implementation uses
any parameters, you can find out by simply calling the <tt>getParameters</tt>
method of your Cipher object and checking the value returned. A return
value of <tt>null</tt> indicates that no parameters were used.
<p>The following cipher algorithms implemented by the SunJCE provider use
parameters:

<ul>
<li>
DES, DES-EDE, and Blowfish, when used in feedback (i.e., CBC, CFB, OFB,
or PCBC) mode, use an initialization vector (IV). The
<tt>javax.crypto.spec.IvParameterSpec</tt>
class can be used to initialize a Cipher object with a given IV.</li>
<P>
<li>
PBEWithMD5AndDES uses a set of parameters, comprising a salt and an iteration
count. The <tt>javax.crypto.spec.PBEParameterSpec</tt> class can be used
to initialize a Cipher object implementing PBEWithMD5AndDES with a given
salt and iteration count.</li>
</ul>
<P>
Note that you do not have to worry about storing or transferring any algorithm
parameters for use by the decryption operation if you use the <tt><a href="#SealedObject">SealedObject</a></tt>
class. This class attaches the parameters used for sealing (encryption)
to the encrypted object contents, and uses the same parameters for unsealing
(decryption).</blockquote>

<h4>
Cipher Output Considerations</h4>

<blockquote>Some of the <tt>update</tt> and <tt>doFinal</tt> methods of
Cipher allow the caller to specify the output buffer into which to encrypt
or decrypt the data. In these cases, it is important to pass a buffer that
is large enough to hold the result of the encryption or decryption operation.
<p>The following method in Cipher can be used to determine how big the
output buffer should be:
<pre>&nbsp;&nbsp;&nbsp; public int getOutputSize(int inputLen)</pre>
</blockquote>
</blockquote>

<h2>
<a NAME="CipherStream"></a>The Cipher Stream Classes</h2>

<blockquote>JCE 1.2.2 introduces the concept of secure streams, which combine
an InputStream or OutputStream with a Cipher object. Secure streams are
provided by the <tt>CipherInputStream</tt> and
<tt>CipherOutputStream</tt>
classes.
<blockquote>

<h3>
<a NAME="CipherInput"></a>The CipherInputStream Class</h3>

<blockquote>This class is a <tt>FilterInputStream</tt> that encrypts or
decrypts the data passing through it. It is composed of an
<tt>InputStream</tt>,
or one of its subclasses, and a
<tt>Cipher</tt>. CipherInputStream represents
a secure input stream into which a Cipher object has been interposed. The
<tt>read</tt>
methods of CipherInputStream return data that are read from the underlying
InputStream but have additionally been processed by the embedded Cipher
object. The Cipher object must be fully initialized before being used by
a CipherInputStream.
<p>For example, if the embedded Cipher has been initialized for decryption,
the CipherInputStream will attempt to decrypt the data it reads from the
underlying InputStream before returning them to the application.
<p>This class adheres strictly to the semantics, especially the failure
semantics, of its ancestor classes
<tt>java.io.FilterInputStream</tt> and
<tt>java.io.InputStream</tt>.
This class has exactly those methods specified in its ancestor classes,
and overrides them all, so that the data are additonally processed by the
embedded cipher. Moreover, this class catches all exceptions that are not
thrown by its ancestor classes. In particular, the <tt>skip(long)</tt>
method skips only data that have been processed by the Cipher.
<p>It is crucial for a programmer using this class not to use methods that
are not defined or overridden in this class (such as a new method or constructor
that is later added to one of the super classes), because the design and
implementation of those methods are unlikely to have considered security
impact with regard to CipherInputStream.
<p>As an example of its usage, suppose <tt>cipher1</tt> has been initialized
for encryption. The code below demonstrates how to use a CipherInputStream
containing that cipher and a FileInputStream in order to encrypt input
stream data:
<pre>&nbsp;&nbsp;&nbsp; FileInputStream fis;
&nbsp;&nbsp;&nbsp; FileOutputStream fos;
&nbsp;&nbsp;&nbsp; CipherInputStream cis;

&nbsp;&nbsp;&nbsp; fis = new FileInputStream("/tmp/a.txt");
&nbsp;&nbsp;&nbsp; cis = new CipherInputStream(fis, cipher1);
&nbsp;&nbsp;&nbsp; fos = new FileOutputStream("/tmp/b.txt");
&nbsp;&nbsp;&nbsp; byte[] b = new byte[8];
&nbsp;&nbsp;&nbsp; int i = cis.read(b);
&nbsp;&nbsp;&nbsp; while (i != -1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fos.write(b, 0, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = cis.read(b);
&nbsp;&nbsp;&nbsp; }</pre>
The above program reads and encrypts the content from the file
<tt>/tmp/a.txt</tt>
and then stores the result (the encrypted bytes) in
<tt>/tmp/b.txt</tt>.
<p>The following example demonstrates how to easily connect several instances
of CipherInputStream and FileInputStream. In this example, assume that
<tt>cipher1</tt>
and
<tt>cipher2</tt> have been initialized for encryption and decryption
(with corresponding keys), respectively.
<pre>&nbsp;&nbsp;&nbsp; FileInputStream fis;
&nbsp;&nbsp;&nbsp; FileOutputStream fos;
&nbsp;&nbsp;&nbsp; CipherInputStream cis1, cis2;

&nbsp;&nbsp;&nbsp; fis = new FileInputStream("/tmp/a.txt");
&nbsp;&nbsp;&nbsp; cis1 = new CipherInputStream(fis, cipher1);
&nbsp;&nbsp;&nbsp; cis2 = new CipherInputStream(cis1, cipher2);
&nbsp;&nbsp;&nbsp; fos = new FileOutputStream("/tmp/b.txt");
&nbsp;&nbsp;&nbsp; byte[] b = new byte[8];
&nbsp;&nbsp;&nbsp; int i = cis2.read(b);
&nbsp;&nbsp;&nbsp; while (i != -1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fos.write(b, 0, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = cis2.read(b);
&nbsp;&nbsp;&nbsp; }</pre>
The above program copies the content from file <tt>/tmp/a.txt</tt> to
<tt>/tmp/b.txt</tt>,
except that the content is first encrypted and then decrypted back when
it is read from <tt>/tmp/a.txt</tt>. Of course since this program simply
encrypts text and decrypts it back right away, it's actually not very useful
except as a simple way of illustrating chaining of CipherInputStreams.</blockquote>

<h3>
<a NAME="CipherOutput"></a>The CipherOutputStream Class</h3>

<blockquote>This class is a <tt>FilterOutputStream</tt> that encrypts or
decrypts the data passing through it. It is composed of an
<tt>OutputStream</tt>,
or one of its subclasses, and a
<tt>Cipher</tt>. CipherOutputStream represents
a secure output stream into which a Cipher object has been interposed.
The
<tt>write</tt> methods of CipherOutputStream first process the data
with the embedded Cipher object before writing them out to the underlying
OutputStream. The Cipher object must be fully initialized before being
used by a CipherOutputStream.
<p>For example, if the embedded Cipher has been initialized for encryption,
the CipherOutputStream will encrypt its data, before writing them out to
the underlying output stream.
<p>This class adheres strictly to the semantics, especially the failure
semantics, of its ancestor classes <tt>java.io.OutputStream</tt> and
<tt>java.io.FilterOutputStream</tt>.
This class has exactly those methods specified in its ancestor classes,
and overrides them all, so that all data are additionally processed by
the embedded cipher. Moreover, this class catches all exceptions that are
not thrown by its ancestor classes.
<p>It is crucial for a programmer using this class not to use methods that
are not defined or overridden in this class (such as a new method or constructor
that is later added to one of the super classes), because the design and
implementation of those methods are unlikely to have considered security
impact with regard to CipherOutputStream.
<p>As an example of its usage, suppose <tt>cipher1</tt> has been initialized
for encryption. The code below demonstrates how to use a CipherOutputStream
containing that cipher and a FileOutputStream in order to encrypt data
to be written to an output stream:
<pre>&nbsp;&nbsp;&nbsp; FileInputStream fis;
&nbsp;&nbsp;&nbsp; FileOutputStream fos;
&nbsp;&nbsp;&nbsp; CipherOutputStream cos;

&nbsp;&nbsp;&nbsp; fis = new FileInputStream("/tmp/a.txt");
&nbsp;&nbsp;&nbsp; fos = new FileOutputStream("/tmp/b.txt");
&nbsp;&nbsp;&nbsp; cos = new CipherOutputStream(fos, cipher1);
&nbsp;&nbsp;&nbsp; byte[] b = new byte[8];
&nbsp;&nbsp;&nbsp; int i = fis.read(b);
&nbsp;&nbsp;&nbsp; while (i != -1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos.write(b, 0, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = fis.read(b);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; cos.flush();</pre>
The above program reads the content from the file
<tt>/tmp/a.txt</tt>,
then encrypts and stores the result (the encrypted bytes) in
<tt>/tmp/b.txt</tt>.
<p>The following example demonstrates how to easily connect several instances
of CipherOutputStream and FileOutputStream. In this example, assume that
<tt>cipher1</tt>
and
<tt>cipher2</tt> have been initialized for decryption and encryption
(with corresponding keys), respectively:
<pre>&nbsp;&nbsp;&nbsp; FileInputStream fis;
&nbsp;&nbsp;&nbsp; FileOutputStream fos;
&nbsp;&nbsp;&nbsp; CipherOutputStream cos1, cos2;

&nbsp;&nbsp;&nbsp; fis = new FileInputStream("/tmp/a.txt");
&nbsp;&nbsp;&nbsp; fos = new FileOutputStream("/tmp/b.txt");
&nbsp;&nbsp;&nbsp; cos1 = new CipherOutputStream(fos, cipher1);
&nbsp;&nbsp;&nbsp; cos2 = new CipherOutputStream(cos1, cipher2);
&nbsp;&nbsp;&nbsp; byte[] b = new byte[8];
&nbsp;&nbsp;&nbsp; int i = fis.read(b);
&nbsp;&nbsp;&nbsp; while (i != -1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cos2.write(b, 0, i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = fis.read(b);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; cos2.flush();</pre>
The above program copies the content from file <tt>/tmp/a.txt</tt> to
<tt>/tmp/b.txt</tt>,
except that the content is first encrypted and then decrypted back before
it is written to <tt>/tmp/b.txt</tt>.
<p>There is one important difference between the <tt>flush</tt> and <tt>close</tt>
methods of this class, which becomes even more relevant if the encapsulated
Cipher object implements a block cipher algorithm with padding turned on:
<p><tt>flush</tt> flushes the underlying OutputStream by forcing any buffered
output bytes that have already been processed by the encapsulated Cipher
object to be written out. Any bytes buffered by the encapsulated Cipher
object and waiting to be processed by it will
<b>not</b> be written out.
<p><tt>close</tt> closes the underlying OutputStream and releases any system
resources associated with it. It invokes the
<tt>doFinal</tt> method of
the encapsulated Cipher object, causing any bytes buffered by it to be
processed and written out to the underlying stream by calling its <tt>flush</tt>
method.</blockquote>

</blockquote>
</blockquote>

<h2>
<a NAME="KeyGenerator"></a>The KeyGenerator Class</h2>

<blockquote>A key generator is used to generate secret keys for symmetric
algorithms.
<h4>
Creating a Key Generator</h4>

<blockquote>Like other engine classes in the API, KeyGenerator objects
are created using the <tt>getInstance</tt> factory methods of the KeyGenerator
class. A factory method is a static method that returns an instance of
a class, in this case, an instance of
<tt>KeyGenerator</tt> which provides
an implementation of the requested key generator.
<p><tt>getInstance</tt> takes as its argument the name of a symmetric algorithm
for which a secret key is to be generated. Optionally, a package provider
name may be specified:
<pre>&nbsp;&nbsp;&nbsp; public static KeyGenerator getInstance(String algorithm);

&nbsp;&nbsp;&nbsp; public static KeyGenerator getInstance(String algorithm,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String provider);</pre>
If just an algorithm name is specified, the system will determine if there
is an implementation of the requested key generator available in the environment,
and if there is more than one, if there is a preferred one.
<p>If both an algorithm name and a package provider are specified, the
system will determine if there is an implementation of the requested key
generator in the package requested, and throw an exception if there is
not.</blockquote>

<h4>
Initializing a KeyGenerator Object</h4>

<blockquote>A key generator for a particular symmetric-key algorithm creates
a symmetric key that can be used with that algorithm. It also associates
algorithm-specific parameters (if any) with the generated key.
<p>There are two ways to generate a key: in an algorithm-independent manner,
and in an algorithm-specific manner. The only difference between the two
is the initialization of the object:
<P>
<ul>
<li>
<b>Algorithm-Independent Initialization</b>

<br>All key generators share the concepts of a <i>keysize</i> and a
<i>source
of randomness</i>. There is an <tt>init</tt> method that takes these two
universally shared types of arguments. There is also one that takes just
a <tt>keysize</tt> argument, and uses a system-provided source of randomness,
and one that takes just a source of randomness:
<pre>&nbsp;&nbsp;&nbsp; public void init(SecureRandom random);

&nbsp;&nbsp;&nbsp; public void init(int keysize);

&nbsp;&nbsp;&nbsp; public void init(int keysize, SecureRandom random);</pre>
Since no other parameters are specified when you call the above algorithm-independent
<tt>init</tt>
methods, it is up to the provider what to do about the algorithm-specific
parameters (if any) to be associated with the generated key.
<P>
<li>
<b>Algorithm-Specific Initialization</b></li>

<br>For situations where a set of algorithm-specific parameters already
exists, there are two <tt>init</tt> methods that have an
<tt>AlgorithmParameterSpec</tt>
argument. One also has a
<tt>SecureRandom</tt> argument, while the source
of randomness is system-provided for the other:
<pre>&nbsp;&nbsp;&nbsp; public void init(AlgorithmParameterSpec params);

&nbsp;&nbsp;&nbsp; public void init(AlgorithmParameterSpec params,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecureRandom random);</pre>
</ul>
In case the client does not explicitly initialize the KeyGenerator (via
a call to an <tt>init</tt> method), each provider must supply (and document)
a default initialization.</blockquote>

<h4>
Creating a Key</h4>

<blockquote>The following method generates a secret key:
<pre>&nbsp;&nbsp;&nbsp; public SecretKey generateKey();</pre>
</blockquote>
</blockquote>

<h2>
<a NAME="SecretFactory"></a>The SecretKeyFactory Class</h2>

<blockquote>This class represents a factory for secret keys.
<p>Key factories are used to convert <i>keys</i> (opaque cryptographic
keys of type <tt>java.security.Key</tt>) into <i>key specifications</i>
(transparent representations of the underlying key material in a suitable
format), and vice versa.
<p>A <tt>javax.crypto.SecretKeyFactory</tt> object operates only on secret
(symmetric) keys, whereas a <tt>java.security.KeyFactory</tt> object processes
the public and private key components of a key pair.
<p>Objects of type <tt>java.security.Key</tt>, of which
<tt>java.security.PublicKey</tt>,
<tt>java.security.PrivateKey</tt>,
and
<tt>javax.crypto.SecretKey</tt> are subclasses, are opaque key objects,
because you cannot tell how they are implemented. The underlying implementation
is provider-dependent, and may be software or hardware based. Key factories
allow providers to supply their own implementations of cryptographic keys.
<p>For example, if you have a key specification for a Diffie Hellman public
key, consisting of the public value <tt>y</tt>, the prime modulus <tt>p</tt>,
and the base <tt>g</tt>, and you feed the same specification to Diffie-Hellman
key factories from different providers, the resulting <tt>PublicKey</tt>
objects will most likely have different underlying implementations.
<p>A provider should document the key specifications supported by its secret
key factory. For example, the <tt>SecretKeyFactory</tt> for DES keys supplied
by the "SunJCE" provider supports <tt>DESKeySpec</tt> as a transparent
representation of DES keys, the
<tt>SecretKeyFactory</tt> for DES-EDE keys
supports
<tt>DESedeKeySpec</tt> as a transparent representation of DES-EDE
keys, and the <tt>SecretKeyFactory</tt> for PBE supports
<tt>PBEKeySpec</tt>
as a transparent representation of the underlying password.
<p>The following is an example of how to use a
<tt>SecretKeyFactory</tt>
to convert secret key data into a
<tt>SecretKey</tt> object, which can
be used for a subsequent
<tt>Cipher</tt> operation:
<pre>&nbsp;&nbsp;&nbsp; // Note the following bytes are not realistic secret key data&nbsp;
&nbsp;&nbsp;&nbsp; // bytes but are simply supplied as an illustration of using data
&nbsp;&nbsp;&nbsp; // bytes (key material) you already have to build a DESKeySpec.
&nbsp;&nbsp;&nbsp; byte[] desKeyData = { (byte)0x01, (byte)0x02, (byte)0x03,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07, (byte)0x08 };
&nbsp;&nbsp;&nbsp; DESKeySpec desKeySpec = new DESKeySpec(desKeyData);
&nbsp;&nbsp;&nbsp; SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
&nbsp;&nbsp;&nbsp; SecretKey secretKey = keyFactory.generateSecret(desKeySpec);</pre>
In this case, the underlying implementation of
<tt>secretKey</tt> is based
on the provider of
<tt>keyFactory</tt>.
<p>An alternative, provider-independent way of creating a functionally
equivalent <tt>SecretKey</tt> object from the same key material is to use
the
<tt>javax.crypto.spec.SecretKeySpec</tt> class, which implements the
<tt>javax.crypto.SecretKey</tt>
interface:
<pre>&nbsp;&nbsp;&nbsp; byte[] desKeyData = { (byte)0x01, (byte)0x02, ...};
&nbsp;&nbsp;&nbsp; SecretKeySpec secretKey = new SecretKeySpec(desKeyData, "DES");</pre>
</blockquote>

<h2>
<a NAME="SealedObject"></a>The SealedObject Class</h2>

<blockquote>This class enables a programmer to create an object and protect
its confidentiality with a cryptographic algorithm.
<p>Given any object that implements the <tt>java.io.Serializable</tt> interface,
one can create a <tt>SealedObject</tt> that encapsulates the original object,
in serialized format (i.e., a "deep copy"), and seals (encrypts) its serialized
contents, using a cryptographic algorithm such as DES, to protect its confidentiality.
The encrypted content can later be decrypted (with the corresponding algorithm
using the correct decryption key) and de-serialized, yielding the original
object.
<p>A typical usage is illustrated in the following code segment: In order
to seal an object, you create a <tt>SealedObject</tt> from the object to
be sealed and a fully initialized <tt>Cipher</tt> object that will encrypt
the serialized object contents. In this example, the String "This is a
secret" is sealed using the DES algorithm. Note that any algorithm parameters
that may be used in the sealing operation are stored inside of <tt>SealedObject</tt>:
<pre>&nbsp;&nbsp;&nbsp; // create Cipher object
&nbsp;&nbsp;&nbsp; // Note: sKey is assumed to refer to an already-generated
&nbsp;&nbsp;&nbsp; // secret DES key.
&nbsp;&nbsp;&nbsp; Cipher c = Cipher.getInstance("DES");
&nbsp;&nbsp;&nbsp; c.init(Cipher.ENCRYPT_MODE, sKey);

&nbsp;&nbsp;&nbsp; // do the sealing
&nbsp;&nbsp;&nbsp; SealedObject so = new SealedObject("This is a secret", c);</pre>
The original object that was sealed can be recovered in two different ways:
<ul>
<li>
by using a <tt>Cipher</tt> object that has been initialized with the exact
same algorithm, key, padding scheme, etc., that were used to seal the object:</li>

<P>
<pre>&nbsp;&nbsp;&nbsp; c.init(Cipher.DECRYPT_MODE, sKey);
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String s = (String)so.getObject(c);
&nbsp;&nbsp;&nbsp; } catch (Exception e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do something
&nbsp;&nbsp;&nbsp; };</pre>
This approach has the advantage that the party who unseals the sealed object
does not require knowledge of the decryption key. For example, after one
party has initialized the cipher object with the required decryption key,
it could hand over the cipher object to another party who then unseals
the sealed object.
<li>
by using the appropriate decryption key (since DES is a symmetric encryption
algorithm, we use the same key for sealing and unsealing):</li>

<P>
<pre>&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String s = (String)so.getObject(sKey);
&nbsp;&nbsp;&nbsp; } catch (Exception e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do something
&nbsp;&nbsp;&nbsp; };</pre>
In this approach, the <tt>getObject</tt> method creates a cipher object
for the appropriate decryption algorithm and initializes it with the given
decryption key and the algorithm parameters (if any) that were stored in
the sealed object. This approach has the advantage that the party who unseals
the object does not need to keep track of the parameters (e.g., the IV)
that were used to seal the object.</ul>
</blockquote>

<h2>
<a NAME="KeyAgreement"></a>The KeyAgreement Class</h2>

<blockquote>The KeyAgreement class provides the functionality of a key
agreement protocol. The keys involved in establishing a shared secret are
created by one of the key generators (<tt>KeyPairGenerator</tt> or <tt>KeyGenerator</tt>),
a
<tt>KeyFactory</tt>, or as a result from an intermediate phase of the
key agreement protocol.
<h4>
Creating a KeyAgreement Object</h4>

<blockquote>Each party involved in the key agreement has to create a KeyAgreement
object. Like other engine classes in the API, KeyAgreement objects are
created using the <tt>getInstance</tt> factory methods of the KeyAgreement
class. A factory method is a static method that returns an instance of
a class, in this case, an instance of <tt>KeyAgreement</tt> which provides
the requested key agreement algorithm.
<p><tt>getInstance</tt> takes as its argument the name of a key agreement
algorithm. Optionally, a package provider name may be specified:
<pre>&nbsp;&nbsp;&nbsp; public static KeyAgreement getInstance(String algorithm);

&nbsp;&nbsp;&nbsp; public static KeyAgreement getInstance(String algorithm,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String provider);</pre>
If just an algorithm name is specified, the system will determine if there
is an implementation of the requested key agreement available in the environment,
and if there is more than one, if there is a preferred one.
<p>If both an algorithm name and a package provider are specified, the
system will determine if there is an implementation of the requested key
agreement in the package requested, and throw an exception if there is
not.</blockquote>

<h4>
Initializing a KeyAgreement Object</h4>

<blockquote>You initialize a KeyAgreement object with your private information.
In the case of Diffie-Hellman, you initialize it with your Diffie-Hellman
private key. Additional initialization information may contain a source
of randomness and/or a set of algorithm parameters. Note that if the requested
key agreement algorithm requires the specification of algorithm parameters,
and only a key, but no parameters are provided to initialize the KeyAgreement
object, the key must contain the required algorithm parameters. (For example,
the Diffie-Hellman algorithm uses a prime modulus <tt>p</tt> and a base
generator <tt>g</tt> as its parameters.)
<p>To initialize a KeyAgreement object, call one of its <tt>init</tt> methods:
<pre>&nbsp;&nbsp;&nbsp; public void init(Key key);

&nbsp;&nbsp;&nbsp; public void init(Key key, SecureRandom random);

&nbsp;&nbsp;&nbsp; public void init(Key key, AlgorithmParameterSpec params);

&nbsp;&nbsp;&nbsp; public void init(Key key, AlgorithmParameterSpec params,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecureRandom random);</pre>
</blockquote>

<h4>
Executing a KeyAgreement Phase</h4>

<blockquote>Every key agreement protocol consists of a number of phases
that need to be executed by each party involved in the key agreement.
<p>To execute the next phase in the key agreement, call the
<tt>doPhase</tt>
method:
<pre>&nbsp;&nbsp;&nbsp; public Key doPhase(Key key, boolean lastPhase);</pre>
The <tt>key</tt> parameter contains the key to be processed by that phase.
In most cases, this is the public key of one of the other parties involved
in the key agreement, or an intermediate key that was generated by a previous
phase. <tt>doPhase</tt> may return an intermediate key that you may have
to send to the other parties of this key agreement, so they can process
it in a subsequent phase.
<p>The <tt>lastPhase</tt> parameter specifies whether or not the phase
to be executed is the last one in the key agreeement: A value of
<tt>FALSE</tt>
indicates that this is not the last phase of the key agreement (there are
more phases to follow), and a value of
<tt>TRUE</tt> indicates that this
is the last phase of the key agreement and the key agreement is completed,
i.e.,
<tt>generateSecret</tt> can be called next.
<p>In the example of Diffie-Hellman between two parties (see
<a href="#AppE">Appendix
E</a>), you call
<tt>doPhase</tt> once, with <tt>lastPhase</tt> set to
<tt>TRUE</tt>.
In the example of Diffie-Hellman between three parties, you call <tt>doPhase</tt>
twice: the first time with
<tt>lastPhase</tt> set to <tt>FALSE</tt>, the
2nd time with
<tt>lastPhase</tt> set to <tt>TRUE</tt>.</blockquote>

<h4>
Generating the Shared Secret</h4>

<blockquote>After each party has executed all the required key agreement
phases, it can compute the shared secret by calling one of the
<tt>generateSecret</tt>
methods:
<pre>&nbsp;&nbsp;&nbsp; public byte[] generateSecret();

&nbsp;&nbsp;&nbsp; public int generateSecret(byte[] sharedSecret, int offset);

&nbsp;&nbsp;&nbsp; public SecretKey generateSecret(String algorithm);</pre>
</blockquote>
</blockquote>

<h2>
<a NAME="Mac"></a>The Mac Class</h2>

<blockquote>The Mac class provides the functionality of a Message Authentication
Code (MAC). Please refer to the <a href="#HmacEx">code example</a> in Appendix
E.
<h4>
Creating a Mac Object</h4>

<blockquote>Like other engine classes in the API, Mac objects are created
using the <tt>getInstance</tt> factory methods of the Mac class. A factory
method is a static method that returns an instance of a class, in this
case, an instance of <tt>Mac</tt> which provides the requested MAC algorithm.
<p><tt>getInstance</tt> takes as its argument the name of a MAC algorithm.
Optionally, a package provider name may be specified:
<pre>&nbsp;&nbsp;&nbsp; public static Mac getInstance(String algorithm);

&nbsp;&nbsp;&nbsp; public static Mac getInstance(String algorithm,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String provider);</pre>
If just an algorithm name is specified, the system will determine if there
is an implementation of the requested MAC algorithm available in the environment,
and if there is more than one, if there is a preferred one.
<p>If both an algorithm name and a package provider are specified, the
system will determine if there is an implementation of the requested MAC
algorithm in the package requested, and throw an exception if there is
not.</blockquote>

<h4>
Initializing a Mac Object</h4>

<blockquote>A Mac object is always initialized with a (secret) key and
may optionally be initialized with a set of parameters, depending on the
underlying MAC algorithm.
<p>To initialize a Mac object, call one of its <tt>init</tt> methods:
<pre>&nbsp;&nbsp;&nbsp; public void init(Key key);

&nbsp;&nbsp;&nbsp; public void init(Key key, AlgorithmParameterSpec params);</pre>
You can initialize your Mac object with any (secret-)key object that implements
the <tt>javax.crypto.SecretKey</tt> interface. This could be an object
returned by
<tt>javax.crypto.KeyGenerator.generateKey()</tt>, or one that
is the result of a key agreement protocol, as returned by
<tt>javax.crypto.KeyAgreement.generateSecret()</tt>,
or an instance of <tt>javax.crypto.spec.SecretKeySpec</tt>.
<p>With some MAC algorithms, the (secret-)key algorithm associated with
the (secret-)key object used to initialize the Mac object does not matter
(this is the case with the HMAC-MD5 and HMAC-SHA1 implementations of the
SunJCE provider). With others, however, the (secret-)key algorithm does
matter, and an
<tt>InvalidKeyException</tt> is thrown if a (secret-)key
object with an inappropriate (secret-)key algorithm is used.</blockquote>

<h4>
Computing a MAC</h4>

<blockquote>A MAC can be computed in one step (<i>single-part operation</i>)
or in multiple steps (<i>multiple-part operation</i>). A multiple-part
operation is useful if you do not know in advance how long the data is
going to be, or if the data is too long to be stored in memory all at once.
<p>To compute the MAC of some data in a single step, call the following
<tt>doFinal</tt>
method:
<pre>&nbsp;&nbsp;&nbsp; public byte[] doFinal(byte[] input);</pre>
To compute the MAC of some data in multiple steps, call one of the
<tt>update</tt>
methods:
<pre>&nbsp;&nbsp;&nbsp; public void update(byte input);

&nbsp;&nbsp;&nbsp; public void update(byte[] input);

&nbsp;&nbsp;&nbsp; public void update(byte[] input, int inputOffset, int inputLen);</pre>
A multiple-part operation must be terminated by the above
<tt>doFinal</tt>
method (if there is still some input data left for the last step), or by
one of the following <tt>doFinal</tt> methods (if there is no input data
left for the last step):
<pre>&nbsp;&nbsp;&nbsp; public byte[] doFinal();

&nbsp;&nbsp;&nbsp; public void doFinal(byte[] output, int outOffset);</pre>
</blockquote>
</blockquote>
</ul>
</blockquote>

<h1>
<a NAME="ExemptApps"></a>How to Make Applications "Exempt" from Cryptographic
Restrictions</h1>

<blockquote>
<blockquote><i><font color="#FF0000">[Note 1: This section should be ignored
by most application developers. It is only for people whose applications
may be exported to those few countries whose governments mandate cryptographic
restrictions, if it desired that such applications have fewer cryptographic
restrictions than those mandated. If you want to skip this section, you
can go on to <a href="#InstallProvider">Installing Providers for JCE 1.2.2</a>.]</font></i>
</blockquote>

<blockquote><i><font color="#FF0000">[Note 2: Throughout this section,
the term "application" is meant to encompass both applications and applets.]</font></i>
</blockquote>
The JCE 1.2.2 framework includes an ability to enforce restrictions regarding
the cryptographic algorithms and maximum cryptographic strengths available
to applets/applications in different jurisdiction contexts (locations).
Any such restrictions are specified in "jurisdiction policy files" that
are downloaded along with the JCE 1.2.2 software. The JCE 1.2.2 software
from Sun Microsystems has a single distribution for both domestic and global
users. The bundled jurisdiction policy files contain <i>no</i> restrictions
on cryptographic strengths. This is appropriate for most countries. Other
framework vendors could create download bundles that include jurisdiction
policy files that specify cryptographic restrictions appropriate for countries
whose governments mandate restrictions. Users in those countries could
download an appropriate bundle, and the JCE framework will enforce the
specified restrictions.
<p>It is possible that the governments of some or all such countries may
allow certain applications to become exempt from some or all cryptographic
restrictions. For example, they may consider certain types of applications
as "special" and thus exempt. Or they may exempt any application that utilizes
an "exemption mechanism," such as key recovery. Applications deemed to
be exempt could get access to stronger cryptography than that allowed for
non-exempt applications in such countries.
<p>In order for an application to be recognized as "exempt" at runtime,
it must meet the following conditions:
<ul>
<li>
It must have a permission policy file bundled with it in a JAR file. The
permission policy file specifies what cryptography-related permissions
the application has, and under what conditions (if any).</li>

<P>
<li>
The JAR file containing the application and the permission policy file
must have been signed using a code-signing certificate issued after the
application was accepted as exempt.</li>
</ul>
Below are sample steps required in order to make an application exempt
from some or all cryptographic restrictions. This is a basic outline that
includes information about what is required by JCE 1.2.2 in order to recognize
and treat applications as being exempt. You will need to know the exemption
requirements of the particular country or countries in which you would
like your application to be able to be run but whose governments require
cryptographic restrictions. You will also need to know the requirements
of a JCE 1.2.2 framework vendor that has a process in place for handling
exempt applications. Consult such a vendor for further information. (Note:
The SunJCE provider does not supply an implementation of the ExemptionMechanismSpi
class.)
<ul>
<li>
Step 1: Write and Compile Your Application Code</li>

<P>
<li>
Step 2: Create a Permission Policy File Granting Appropriate Cryptographic
Permissions</li>

<P>
<li>
Step 3: Prepare for Testing</li>

<P>
<blockquote>
<li>
Step 3a: Apply for Government Approval</li>

<P>
<li>
Step 3b: Get a Code-Signing Certificate for Testing</li>

<P>
<li>
Step 3c: Bundle the Application and Permission Policy File into a JAR file</li>

<P>
<li>
Step 3d: Sign the JAR file for Testing</li>

<P>
<li>
Step 3e: Set Up Your Environment Like That of a User in a Restricted Country</li>

<P>
<li>
Step 3f: (only for apps using exemption mechanisms) Install a Provider
Implementing the Exemption Mechanism Specified in the Permission Policy
File</li>
</blockquote>

<li>
Step 4: Test Your Application</li>

<P>
<li>
Step 5: Prepare for Production</li>


<blockquote>
<li>
Step 5a: Get a Code-Signing Certificate for Production</li>

<P>
<li>
Step 5b: Bundle the Application and Permission Policy File into a New JAR
file</li>

<P>
<li>
Step 5c: Sign the JAR File for Production</li>
</blockquote>

<li>
Step 6: Run Your Test Programs Again</li>

<P>
<li>
Step 7: Deploy Your Application</li>
</ul>

<h2>
Special Code Requirements for Applications that Use Exemption Mechanisms</h2>

<blockquote>When an application has a permission policy file associated
with it (in the same JAR file) and that permission policy file specifies
an exemption mechanism, then when the Cipher <tt>getInstance</tt> method
is called to instantiate a Cipher, the JCE 1.2.2 code searches the installed
providers for one that implements the specified exemption mechanism. If
it finds such a provider, JCE 1.2.2 instantiates an ExemptionMechanism
API object associated with the provider's implementation, and then associates
the ExemptionMechanism object with the Cipher returned by
<tt>getInstance</tt>.
<p>After instantiating a Cipher, and prior to initializing it (via a call
to the Cipher <tt>init</tt> method), your code must call the following
Cipher method:
<pre>&nbsp;&nbsp;&nbsp; public ExemptionMechanism getExemptionMechanism()</pre>
This call returns the ExemptionMechanism object associated with the Cipher.
You must then initialize the exemption mechanism implementation by calling
the following method on the returned ExemptionMechanism:
<pre>&nbsp;&nbsp;&nbsp;&nbsp; public final void init(Key key)</pre>
The argument you supply should be the same as the argument of the same
types that you will subsequently supply to a Cipher <tt>init</tt> method.
<p>Once you have initialized the ExemptionMechanism, you can proceed as
usual to initialize and use the Cipher.</blockquote>

<h2>
Permission Policy Files</h2>

<blockquote>In order for an application to be recognized at runtime as
being "exempt" from some or all cryptographic restrictions, it must have
a permission policy file bundled with it in a JAR file. The permission
policy file specifies what cryptography-related permissions the application
has, and under what conditions (if any).
<p><i><font color="#FF0000">Note: The permission policy file bundled with
an application must be named <b><tt>cryptoPerms</tt></b>.</font></i>
<p>The format of a permission entry in a permission policy file that accompanies
an exempt application is the same as the format for a jurisdiction policy
file downloaded with JCE 1.2.2, which is:
<blockquote>
<pre>permission &lt;crypto permission class name>[ &lt;alg_name>
&nbsp;&nbsp;&nbsp; [[, &lt;exemption mechanism name>][, &lt;maxKeySize>
&nbsp;&nbsp;&nbsp; [, &lt;AlgorithmParameterSpec class name>,
&nbsp;&nbsp;&nbsp; &lt;parameters for constructing an AlgorithmParameterSpec object>]]]];</pre>
</blockquote>
See <a href="#AppD">Appendix D</a> for more information about the jurisdiction
policy file format.
<h3>
Permission Policy Files for Exempt Applications</h3>

<blockquote>Some applications may be allowed to be completely unrestricted.
Thus, the permission policy file that accompanies such an application usually
just needs to contain the following:
<blockquote>
<pre>grant {
&nbsp;&nbsp;&nbsp; // There are no restrictions to any algorithms.
&nbsp;&nbsp;&nbsp; permission javax.crypto.CryptoAllPermission;
};</pre>
</blockquote>
If an application just uses a single algorithm (or several specific algorithms),
then the permission policy file could simply mention that algorithm (or
algorithms) explicitly, rather than granting CryptoAllPermission. For example,
if an application just uses the Blowfish algorithm, the permission policy
file doesn't have to grant CryptoAllPermission to all algorithms. It could
just specify that there is no cryptographic restriction if the Blowfish
algorithm is used. In order to do this, the permission policy file would
look like the following:
<blockquote>
<pre>grant {
&nbsp;&nbsp;&nbsp; permission javax.crypto.CryptoPermission "Blowfish";
};</pre>
</blockquote>
</blockquote>

<h3>
Permission Policy Files for Applications Exempt Due to Exemption Mechanisms</h3>

<blockquote>If an application is considered "exempt" if an exemption mechanism
is enforced, then the permission policy file that accompanies the application
must specify one or more exemption mechanisms. At runtime, the application
will be considered exempt if any of those exemption mechanisms is enforced.
Each exemption mechanism must be specified in a permission entry that looks
like the following:
<blockquote>
<pre>&nbsp;&nbsp;&nbsp; // No algorithm restrictions if specified
&nbsp;&nbsp;&nbsp; // exemption mechanism is enforced.
&nbsp;&nbsp;&nbsp; permission javax.crypto.CryptoPermission *,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;ExemptionMechanismName>";</pre>
</blockquote>
where <tt>&lt;ExemptionMechanismName></tt> specifies the name of an exemption
mechanism. The list of possible exemption mechanism names includes:
<ul>
<li>
KeyRecovery</li>

<P>
<li>
KeyEscrow</li>

<P>
<li>
KeyWeakening</li>
</ul>
As an example, suppose your application is exempt if either key recovery
or key escrow is enforced. Then your permission policy file should contain
the following:
<blockquote>
<pre>grant {
&nbsp;&nbsp;&nbsp; // No algorithm restrictions if KeyRecovery is enforced.
&nbsp;&nbsp;&nbsp; permission javax.crypto.CryptoPermission *,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "KeyRecovery";
&nbsp;&nbsp;&nbsp; // No algorithm restrictions if KeyEscrow is enforced.
&nbsp;&nbsp;&nbsp; permission javax.crypto.CryptoPermission *,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "KeyEscrow";
};</pre>
</blockquote>
Note: Permission entries that specify exemption mechanisms should <i>not</i>
also specify maximum key sizes. The allowed key sizes are actually determined
from the exempt jurisdiction policy files downloaded with JCE 1.2.2, as
described in the next section.</blockquote>

<h3>
How Bundled Permission Policy Files Affect Cryptographic Permissions</h3>

<blockquote>At runtime, when an application instantiates a Cipher (via
a call to its <tt>getInstance</tt> method) and that application has an
associated permission policy file, JCE 1.2.2 checks to see whether the
permission policy file has an entry that applies to the algorithm specified
in the <tt>getInstance</tt> call. If it does, and the entry grants CryptoAllPermission
or does not specify that an exemption mechanism must be enforced, it means
there is no cryptographic restriction for this particular algorithm.
<p>If the permission policy file has an entry that applies to the algorithm
specified in the <tt>getInstance</tt> call and the entry <i>does</i> specify
that an exemption mechanism must be enforced, then the exempt jurisdiction
policy file(s) are examined. If the exempt permissions include an entry
for the relevant algorithm and exemption mechanism, and that entry is implied
by the permissions in the permission policy file bundled with the application,
and if there is an implementation of the specified exemption mechanism
available from one of the registered providers, then the maximum key size
and algorithm parameter values for the Cipher are determined from the exempt
permission entry.
<p>If there is no exempt permission entry implied by the relevant entry
in the permission policy file bundled with the application, or if there
is no implementation of the specified exemption mechanism available from
any of the registered providers, then the application is only allowed the
standard default cryptographic permissions.</blockquote>
</blockquote>
</blockquote>

<h1>
<a NAME="InstallProvider"></a>Installing Providers for JCE 1.2.2</h1>

<blockquote>Cryptographic providers for JCE 1.2.2 are installed and configured
in much the same way as cryptographic providers for the Java<sup><font size=-2>TM</font></sup>
2 platform. The only difference is that when you install a JCE 1.2.2 provider,
you also need to make sure that JCE 1.2.2 is installed. More information
about installing and configuring providers can be found in the <a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/CryptoSpec.html#ProviderInstalling">Installing
Providers</a> section of the <i>Java<sup><font size=-2>TM</font></sup>
Cryptography Architecture API Specification &amp; Reference</i> document.
<p>Installing a provider is done in two steps: <a href="#InstallProv">installing
the provider package classes</a>, and <a href="#Configuring">configuring
the provider</a>. In some situations you will also need to <a href="#SettingPerms">set
permissions</a> for the provider prior to using it.
<h2>
<a NAME="InstallProv"></a>Installing the Provider Classes</h2>

<blockquote>The first thing you must do is make the provider classes available
so that they can be found when requested. Provider classes are shipped
as a JAR (Java ARchive) file.
<p>Note that in order for a provider to work, you must also have the JCE
1.2.2 framework (more specifically: the <tt>jce1_2_2.jar</tt> file) installed.
If your applet or application utilizes the "SunJCE" provider included with
the JCE 1.2.2 release, then you must also have the "SunJCE" provider (<tt>sunjce_provider.jar</tt>)
installed.
<p><a NAME="InstallOptions"></a>There are two types of JCE installations
supported:
<ul>
<li>
The JCE 1.2.2 framework is an "installed" extension. JCE providers are
installed or bundled.</li>

<P>
<li>
The JCE 1.2.2 framework and JCE providers are located on the class path
(not installed extensions).</li>
</ul>
Thus, there are a couple possible ways of installing provider classes,
depending on how the JCE 1.2.2 framework is installed:
<ul>
<li>
Install the JAR file containing the provider classes as an "installed"
or "bundled" (also known as "download") extension if the JCE 1.2.2 framework
is an installed extension.</li>

<li>
Place the JAR file containing the provider classes anywhere on the CLASSPATH
if the JCE 1.2.2 framework is on the CLASSPATH.</li>
</ul>
Note: A provider JAR file will be considered an installed extension if
it is placed in the standard place for the JAR files of an installed extension:
<blockquote>
<pre>&lt;java-home>\lib\ext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Win32]
&lt;java-home>/lib/ext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Solaris]</pre>
</blockquote>
Here <tt>&lt;java-home></tt> refers to the directory where the runtime
software is installed, which is the top-level directory of the JRE or the
<tt>jre</tt>
directory in the Java<sup><font size=-2>TM</font></sup> 2 SDK software.
For example, if you have J2SDK v 1.2.2 installed on Solaris in a directory
named <tt>jdk1.2.2</tt>, you need to install the JAR file in the following
directory:
<blockquote>
<pre>jdk1.2.2/jre/lib/ext</pre>
</blockquote>
Similarly, if you have Java<sup><font size=-2>TM</font></sup> 2 Runtime
Environment v 1.2.2 installed on Solaris in a directory named <tt>jre1.2.2</tt>,
you need to install the JAR file in the following directory:
<blockquote>
<pre>jre1.2.2/lib/ext</pre>
</blockquote>
If a provider JAR file is placed anywhere other than the standard place
for installed extensions (e.g., in a directory on your class path instead),
it will be considered "bundled."
<p>For more information on "installed" extensions, see <a href="http://java.sun.com/products/jdk/1.2/docs/guide/extensions/spec.html#installed">Installed
Extensions</a>.


<p>For more information on "bundled" extensions, see <a href="http://java.sun.com/products/jdk/1.2/docs/guide/extensions/spec.html#bundled">Bundled
Extensions</a>.</blockquote>

<h2>
<a NAME="Configuring"></a>Configuring the Provider</h2>

<blockquote>The next step is to add the provider to your list of approved
providers. This is done statically by editing the security properties file
<blockquote>
<pre>&lt;java-home>\lib\security\java.security&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Win32]
&lt;java-home>/lib/security/java.security&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Solaris]</pre>
</blockquote>
Here <tt>&lt;java-home></tt> refers to the directory where the JRE was
installed. For example, if you have J2SDK v 1.2.2 installed on Solaris
in a directory named <tt>jdk1.2.2</tt>, you need to edit the following
file:
<blockquote>
<pre>jdk1.2.2/jre/lib/security/java.security</pre>
</blockquote>
Similarly, if you have Java<sup><font size=-2>TM</font></sup> 2 Runtime
Environment, Standard Edition, v 1.2.2 installed on Solaris in a directory
named <tt>jre1.2.2</tt>, you need to edit this file:
<blockquote>
<pre>jre1.2.2/lib/security/java.security</pre>
</blockquote>
For each provider, this file should have a statement of the following form:
<pre>&nbsp;&nbsp;&nbsp; security.provider.<i>n</i>=<i>masterClassName</i></pre>
This declares a provider, and specifies its preference order
<i>n</i>.
The preference order is the order in which providers are searched for requested
algorithms when no specific provider is requested. The order is 1-based;
1 is the most preferred, followed by 2, and so on.
<p><i>masterClassName</i> must specify the fully qualified name of the
provider's "master class". The provider vendor should supply you this name.
<p>J2SE comes standard with a provider named "SUN", which is automatically
configured as a static provider in the
<tt>java.security</tt> properties
file, as follows:
<pre>&nbsp;&nbsp;&nbsp; security.provider.1=sun.security.provider.Sun</pre>
(The "SUN" provider's master class is the <tt>Sun</tt> class in the <tt>sun.security.provider</tt>
package.)
<p>Note that when you install JCE 1.2.2 (the
<tt>jce1_2_2.jar</tt> extension),
the "SunJCE" provider that is also included with the JCE 1.2.2 release
is not automatically installed. That is, if you want to use the "SunJCE"
provider, you need to install the <tt>sunjce_provider.jar</tt> file as
an optional package (extension) and explicitly register the "SunJCE" provider
- either statically or dynamically, as described in this section.
<p>In order to statically add "SunJCE" to your list of providers, you need
to edit the security properties file to contain a line of the format shown
above. For example, to make "SunJCE" the second preferred provider, add
the following line to the <tt>java.security</tt> file below the line for
the "SUN" provider:
<pre>&nbsp;&nbsp;&nbsp; security.provider.2=com.sun.crypto.provider.SunJCE</pre>
Add similar lines to statically register other providers. For example,
suppose that a provider's master class is the <tt>CryptoX</tt> class in
the
<tt>com.cryptox.provider</tt> package, and that you would like to make
this provider the third preferred provider, after the "Sun" and "SunJCE"
providers. To do so, add the following line to the <tt>java.security</tt>
file below the line for the "SunJCE" provider:
<pre>&nbsp;&nbsp;&nbsp; security.provider.3=com.cryptox.provider.CryptoX</pre>
Providers may also be registered dynamically. To do so, a program can call
either the <tt>addProvider</tt> or
<tt>insertProviderAt</tt> method in
the <tt>Security</tt> class. This type of registration is not persistent
and can only be done by "trusted" programs. See the
<a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/CryptoSpec.html#Security">Security</a>
class section of the
<i>Java Cryptography Architecture API Specification
and Reference</i>.
<p>An example of dynamic registration of the "SunJCE" provider is the following:
<pre>&nbsp;&nbsp;&nbsp; Provider sunJce = new com.sun.crypto.provider.SunJCE();
&nbsp;&nbsp;&nbsp; Security.addProvider(sunJce);</pre>
</blockquote>

<h2>
<a NAME="SettingPerms"></a>Setting Provider Permissions</h2>

<blockquote>Whenever the JCE 1.2.2 framework and/or providers are not installed
extensions, <a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/permissions.html">permissions</a>
must be granted for when applets or applications using JCE are run while
a security manager is installed. There is typically a security manager
installed whenever an applet is running, and a security manager may be
installed for an application either via code in the application itself
or via a command-line argument. Permissions do not need to be granted to
installed extensions, since the default system <a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/PolicyFiles.html">policy
configuration file</a> grants all permissions to installed extensions.
<p>The documentation from the vendor of each provider you will be using
should include information as to which permissions it requires, and how
to grant such permissions. For example, permissions are needed by the "SunJCE"
provider if it is not an installed extension and a security manager may
be installed. The permissions it needs can be granted via a statement such
as the following, which could appear in a policy configuration file. In
this example, the JCE 1.2.2 framework is assumed to be an installed extension
located in <tt>/jdk1.2.2/jre/lib/ext</tt> and the <tt>sunjce_provider.jar</tt>
file is assumed to be in the <tt>/localWork</tt> directory.
<blockquote>
<pre>grant codeBase "file:/localWork/sunjce_provider.jar" {
&nbsp; permission java.io.FilePermission
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "/jdk1.2.2/jre/lib/ext/jce1_2_2.jar", "read";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; permission java.lang.RuntimePermission "getProtectionDomain";
&nbsp; permission java.security.SecurityPermission
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "putProviderProperty.SunJCE";
};</pre>
</blockquote>
If you choose the installation option where both the JCE 1.2.2 framework
and JCE providers are on the class path, you will need to grant provider
permissions (as above) and also grant the following permission to the JCE
1.2.2 framework:
<blockquote>
<pre>java.security.AllPermission</pre>
</blockquote>
Below is a sample statement granting this permission. In this example,
the JCE 1.2.2 framework is assumed to be in the
<tt>/home/mydir/working</tt>
directory.
<blockquote>
<pre>grant codeBase "file:/home/mydir/working/jce1_2_2.jar" {
&nbsp; permission java.security.AllPermission;
};</pre>
</blockquote>
</blockquote>
</blockquote>

<h1>
<a NAME="JceKeystore"></a>JCE Keystore</h1>

<blockquote>The "SunJCE" provider supplies its own implementation of the
<tt>java.security.KeyStore</tt>
class in J2SDK. Its implementation employs a much stronger protection of
private keys (using password-based encryption with Triple DES) than the
keystore implementation supplied by the "SUN" provider in J2SDK. (Note
that because J2SDK is distributed world-wide in binary and source format,
it cannot employ any strong encryption mechanisms.)
<p>In order to take advantage of the keystore implementation of the "SunJCE"
provider, you specify "<i>JCEKS</i>" as the keystore type.
<p>You may upgrade your keystore of type "<i>JKS</i>" - this is the name
of the keystore type implemented by the "SUN" provider in J2SDK - to a
JCE 1.2.2 keystore of type "<i>JCEKS</i>" by changing the password of a
private-key entry in your keystore. Note that once you have upgraded your
keystore, your keystore can no longer be accessed without JCE 1.2.2 installed.
<p>To apply the cryptographically strong(er) key protection supplied by
"SunJCE" to a private key named "signkey" in your default keystore, use
the following command, which will prompt you for the old and new key passwords:
<pre>&nbsp;&nbsp;&nbsp; keytool -keypasswd -alias signkey -storetype jceks</pre>
You may want to change the password back to its old value, using the same
command.
<p>See the <a href="http://java.sun.com/products/jdk/1.2/docs/tooldocs/solaris/keytool.html">keytool
user guide</a> for more information about keystores and how they are managed.</blockquote>

<h1>
<a NAME="Examples"></a>Code Examples</h1>

<blockquote>This section is a short tutorial on how to use some of the
major features of the JCE 1.2.2 APIs. Complete sample programs that exercise
the APIs can be found in <a href="#AppE">Appendix E</a> of this document.
<h2>
<a NAME="SimpleEncrEx"></a>Using Encryption</h2>

<blockquote>This section takes the user through the process of generating
a key, creating and initializing a cipher object, encrypting a file, and
then decrypting it. Throughout this example, we use the Data Encryption
Standard (DES).
<h4>
Generating a Key</h4>

<blockquote>To create a DES key, we have to instantiate a KeyGenerator
for DES. We do not specify a provider, because we do not care about a particular
DES key generation implementation. Since we do not initialize the KeyGenerator,
a system-provided source of randomness will be used to create the DES key:
<pre>&nbsp;&nbsp;&nbsp; KeyGenerator keygen = KeyGenerator.getInstance("DES");
&nbsp;&nbsp;&nbsp; SecretKey desKey = keygen.generateKey();</pre>
After the key has been generated, the same KeyGenerator object can be re-used
to create further keys.</blockquote>

<h4>
Creating a Cipher</h4>

<blockquote>The next step is to create a Cipher instance. To do this, we
use one of the <tt>getInstance</tt> factory methods of the Cipher class.
We must specify the name of the requested transformation, which includes
the following components, separated by slashes (/):
<ul>
<li>
the algorithm name</li>

<li>
the mode (optional)</li>

<li>
the padding scheme (optional)</li>
</ul>
In this example, we create a DES (Data Encryption Standard) cipher in Electronic
Codebook mode, with PKCS#5-style padding. We do not specify a provider,
because we do not care about a particular implementation of the requested
transformation.
<p>The standard algorithm name for DES is "DES", the standard name for
the Electronic Codebook mode is "ECB", and the standard name for PKCS#5-style
padding is "PKCS5Padding":
<pre>&nbsp;&nbsp;&nbsp; Cipher desCipher;

&nbsp;&nbsp;&nbsp; // Create the cipher&nbsp;
&nbsp;&nbsp;&nbsp; desCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");</pre>
We use the generated <tt>desKey</tt> from above to initialize the Cipher
object for encryption:
<pre>&nbsp;&nbsp;&nbsp; // Initialize the cipher for encryption
&nbsp;&nbsp;&nbsp; desCipher.init(Cipher.ENCRYPT_MODE, desKey);

&nbsp;&nbsp;&nbsp; // Our cleartext
&nbsp;&nbsp;&nbsp; byte[] cleartext = "This is just an example".getBytes();

&nbsp;&nbsp;&nbsp; // Encrypt the cleartext
&nbsp;&nbsp;&nbsp; byte[] ciphertext = desCipher.doFinal(cleartext);

&nbsp;&nbsp;&nbsp; // Initialize the same cipher for decryption
&nbsp;&nbsp;&nbsp; desCipher.init(Cipher.DECRYPT_MODE, desKey);

&nbsp;&nbsp;&nbsp; // Decrypt the ciphertext
&nbsp;&nbsp;&nbsp; byte[] cleartext1 = desCipher.doFinal(ciphertext);</pre>
<tt>cleartext</tt> and <tt>cleartext1</tt> are identical.</blockquote>
</blockquote>

<h2>
<a NAME="PBEEx"></a>Using Password-Based Encryption</h2>

<blockquote>In this example, we prompt the user for a password from which
we derive an encryption key.
<p>It would seem logical to collect and store the password in an object
of type <tt>java.lang.String</tt>. However, here's the caveat: Objects
of type <tt>String</tt> are immutable, i.e., there are no methods defined
that allow you to change (overwrite) or zero out the contents of a <tt>String</tt>
after usage. This feature makes <tt>String</tt> objects unsuitable for
storing security sensitive information such as user passwords. You should
always collect and store security sensitive information in a char array
instead.
<p>For that reason, the <tt>javax.crypto.spec.PBEKeySpec</tt> class takes
(and returns) a password as a char array.
<p>The following method is an example of how to collect a user password
as a char array:
<pre>&nbsp;&nbsp;&nbsp; /**
&nbsp;&nbsp;&nbsp;&nbsp; * Reads user password from given input stream.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; public char[] readPasswd(InputStream in) throws IOException {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char[] lineBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char[] buf;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf = lineBuffer = new char[128];

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int room = buf.length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int offset = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;

loop:&nbsp;&nbsp; while (true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (c = in.read()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case -1:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '\n':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break loop;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '\r':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c2 = in.read();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((c2 != '\n') &amp;&amp; (c2 != -1)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(in instanceof PushbackInputStream)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in = new PushbackInputStream(in);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((PushbackInputStream)in).unread(c2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break loop;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (--room &lt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf = new char[offset + 128];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; room = buf.length - offset - 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(lineBuffer, 0, buf, 0, offset);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arrays.fill(lineBuffer, ' ');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lineBuffer = buf;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf[offset++] = (char) c;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (offset == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char[] ret = new char[offset];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(buf, 0, ret, 0, offset);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arrays.fill(buf, ' ');

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret;
&nbsp;&nbsp;&nbsp; }</pre>
In order to use Password-Based Encryption (PBE) as defined in PKCS#5, we
have to specify a <i>salt</i> and an <i>iteration count</i>. The same salt
and iteration count that are used for encryption must be used for decryption:
<pre>&nbsp;&nbsp;&nbsp; PBEKeySpec pbeKeySpec;
&nbsp;&nbsp;&nbsp; PBEParameterSpec pbeParamSpec;
&nbsp;&nbsp;&nbsp; SecretKeyFactory keyFac;

&nbsp;&nbsp;&nbsp; // Salt
&nbsp;&nbsp;&nbsp; byte[] salt = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99
&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; // Iteration count
&nbsp;&nbsp;&nbsp; int count = 20;

&nbsp;&nbsp;&nbsp; // Create PBE parameter set
&nbsp;&nbsp;&nbsp; pbeParamSpec = new PBEParameterSpec(salt, count);

&nbsp;&nbsp;&nbsp; // Prompt user for encryption password.
&nbsp;&nbsp;&nbsp; // Collect user password as char array (using the
&nbsp;&nbsp;&nbsp; // "readPasswd" method from above), and convert
&nbsp;&nbsp;&nbsp; // it into a SecretKey object, using a PBE key
&nbsp;&nbsp;&nbsp; // factory.
&nbsp;&nbsp;&nbsp; System.out.print("Enter encryption password:&nbsp; ");
&nbsp;&nbsp;&nbsp; System.out.flush();
&nbsp;&nbsp;&nbsp; pbeKeySpec = new PBEKeySpec(readPasswd(System.in));
&nbsp;&nbsp;&nbsp; keyFac = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
&nbsp;&nbsp;&nbsp; SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);

&nbsp;&nbsp;&nbsp; // Create PBE Cipher
&nbsp;&nbsp;&nbsp; Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES");

&nbsp;&nbsp;&nbsp; // Initialize PBE Cipher with key and parameters
&nbsp;&nbsp;&nbsp; pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

&nbsp;&nbsp;&nbsp; // Our cleartext
&nbsp;&nbsp;&nbsp; byte[] cleartext = "This is another example".getBytes();

&nbsp;&nbsp;&nbsp; // Encrypt the cleartext
&nbsp;&nbsp;&nbsp; byte[] ciphertext = pbeCipher.doFinal(cleartext);</pre>
</blockquote>

<h2>
<a NAME="KeyAgreeEx"></a>Using Key Agreement</h2>

<blockquote>Please refer to <a href="#AppE">Appendix E</a> for sample programs
exercising the Diffie-Hellman key exchange between 2 and 3 parties, respectively.</blockquote>
</blockquote>

<hr>
<h1>
<a NAME="AppA"></a>Appendix A: Standard Names</h1>

<blockquote>The JCE 1.2.2 API requires and utilizes a set of standard names
for algorithms, algorithm modes, and padding schemes. This specification
establishes the following names as standard names. It supplements the list
of standard names defined in <a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/CryptoSpec.html#AppA">Appendix
A</a> in the <i>Java<sup><font size=-2>TM</font></sup> Cryptography Architecture
API Specification &amp; Reference</i>. Note that algorithm names are treated
case-insensitive.
<h2>
Cipher</h2>

<blockquote>
<h4>
Algorithm</h4>

<blockquote>The following names can be specified as the <i>algorithm</i>
component in a <a href="#trans">transformation</a> when requesting an instance
of <b><tt><font size=+1>Cipher</font></tt></b>:


<ul>
<li>
<b>DES</b>: The Digital Encryption Standard as described in FIPS PUB 46-2.</li>

<li>
<b>DESede</b>: Triple DES Encryption (DES-EDE).</li>

<li>
<b>PBEWithMD5AndDES</b>: The password-based encryption algorithm as defined
in: RSA Laboratories, "PKCS #5: Password-Based Encryption Standard," version
1.5, Nov 1993. Note that this algorithm implies <i><a href="#cbcMode">CBC</a></i>
as the cipher mode and <i><a href="#pkcs5Pad">PKCS5Padding</a></i> as the
padding scheme and cannot be used with any other cipher modes or padding
schemes.</li>

<li>
<b>Blowfish</b>: The block cipher designed by Bruce Schneier.</li>
</ul>
</blockquote>

<h4>
Mode</h4>

<blockquote>The following names can be specified as the <i>mode</i> component
in a <a href="#trans">transformation</a> when requesting an instance of
<b><tt><font size=+1>Cipher</font></tt></b>:

<ul>
<li>
<b>ECB</b>: Electronic Codebook Mode, as defined in: The National Institute
of Standards and Technology (NIST) Federal Information Processing Standard
(FIPS) PUB 81, "DES Modes of Operation," U.S. Department of Commerce, Dec
1980.</li>

<li>
<a NAME="cbcMode"></a><b>CBC</b>: Cipher Block Chaining Mode, as defined
in FIPS PUB 81.</li>

<li>
<b>CFB</b>: Cipher Feedback Mode, as defined in FIPS PUB 81.</li>

<li>
<b>OFB</b>: Output Feedback Mode, as defined in FIPS PUB 81.</li>

<li>
<b>PCBC</b>: Plaintext Cipher Block Chaining, as defined by Kerberos.</li>
</ul>
</blockquote>

<h4>
Padding</h4>

<blockquote>The following names can be specified as the <i>padding</i>
component in a <a href="#trans">transformation</a> when requesting an instance
of <b><tt><font size=+1>Cipher</font></tt></b>:

<ul>
<li>
<b>NoPadding</b>: No padding.</li>

<li>
<a NAME="pkcs5Pad"></a><b>PKCS5Padding</b>: The padding scheme described
in: RSA Laboratories, "PKCS #5: Password-Based Encryption Standard," version
1.5, November 1993.</li>

<li>
<b>SSL3Padding</b>: The padding scheme defined in the SSL Protocol Version
3.0, November 18, 1996, section 5.2.3.2 (CBC block cipher):</li>

<pre>&nbsp;&nbsp;&nbsp; block-ciphered struct {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; opaque content[SSLCompressed.length];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; opaque MAC[CipherSpec.hash_size];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8 padding[GenericBlockCipher.padding_length];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8 padding_length;
&nbsp;&nbsp;&nbsp; } GenericBlockCipher;</pre>
The size of an instance of a GenericBlockCipher must be a multiple of the
block cipher's block length.
<p>The padding length, which is always present, contributes to the padding,
which implies that if:
<pre>&nbsp;&nbsp;&nbsp; sizeof(content) + sizeof(MAC) % block_length = 0,</pre>
padding has to be (block_length - 1) bytes long, because of the existence
of
<tt>padding_length</tt>.
<p>This make the padding scheme similar (but not quite) to PKCS5Padding,
where the padding length is encoded in the padding (and ranges from 1 to
block_length). With the SSL scheme, the sizeof(padding) is encoded in the
always present <tt>padding_length</tt> and therefore ranges from 0 to block_length-1.
<p>Note that this padding mechanism is not supported by the "SunJCE" provider.</ul>
</blockquote>
</blockquote>

<h2>
KeyAgreement</h2>

<blockquote>The following algorithm names can be specified when requesting
an instance of <b><tt><font size=+1>KeyAgreement</font></tt></b>:
<ul>
<li>
<b>DiffieHellman</b>: Diffie-Hellman Key Agreement as defined in PKCS #3:
Diffie-Hellman Key-Agreement Standard, RSA Laboratories, version 1.4, November
1993.</li>
</ul>
</blockquote>

<h2>
KeyGenerator</h2>

<blockquote>The following algorithm names can be specified when requesting
an instance of <b><tt><font size=+1>KeyGenerator</font></tt></b>:
<ul>
<li>
<b>DES</b></li>

<li>
<b>DESede</b></li>

<li>
<b>Blowfish</b></li>

<li>
<b>HmacMD5</b></li>

<li>
<b>HmacSHA1</b></li>
</ul>
</blockquote>

<h2>
KeyPairGenerator</h2>

<blockquote>The following algorithm names can be specified when requesting
an instance of <b><tt><font size=+1>KeyPairGenerator</font></tt></b>:
<ul>
<li>
<b>DiffieHellman</b></li>
</ul>
</blockquote>

<h2>
SecretKeyFactory</h2>

<blockquote>The following algorithm names can be specified when requesting
an instance of <b><tt><font size=+1>SecretKeyFactory</font></tt></b>:
<ul>
<li>
<b>DES</b></li>

<li>
<b>DESede</b></li>

<li>
<b>PBEWithMD5AndDES</b>: Secret-key factory for use with PKCS #5 password-based
encryption. Uses only the low order 8 bits of each password character.</li>
</ul>
</blockquote>

<h2>
KeyFactory</h2>

<blockquote>The following algorithm names can be specified when requesting
an instance of <b><tt><font size=+1>KeyFactory</font></tt></b>:
<ul>
<li>
<b>DiffieHellman</b></li>
</ul>
</blockquote>

<h2>
AlgorithmParameterGenerator</h2>

<blockquote>The following algorithm names can be specified when requesting
an instance of
<b><tt><font size=+1>AlgorithmParameterGenerator</font></tt></b>:
<ul>
<li>
<b>DiffieHellman</b></li>
</ul>
</blockquote>

<h2>
AlgorithmParameters</h2>

<blockquote>The following algorithm names can be specified when requesting
an instance of <b><tt><font size=+1>AlgorithmParameters</font></tt></b>:
<ul>
<li>
<b>DiffieHellman</b></li>

<li>
<b>DES</b></li>

<li>
<b>DESede</b></li>

<li>
<b>PBE</b></li>

<li>
<b>Blowfish</b></li>
</ul>
</blockquote>

<h2>
MAC</h2>

<blockquote>The following algorithm names can be specified when requesting
an instance of <b><tt><font size=+1>Mac</font></tt></b>:
<ul>
<li>
<b>HmacMD5</b>: The HMAC-MD5 keyed-hashing algorithm as defined in RFC
2104: "HMAC: Keyed-Hashing for Message Authentication" (February 1997).</li>

<li>
<b>HmacSHA1</b>: The HMAC-SHA1 keyed-hashing algorithm as defined in RFC
2104: "HMAC: Keyed-Hashing for Message Authentication" (February 1997).</li>
</ul>
</blockquote>

<h2>
Keystore Types</h2>

<blockquote>The following types can be specified when requesting an instance
of <b><tt><font size=+1>KeyStore</font></tt></b>:
<ul>
<li>
<b>JCEKS</b>: The <a href="#JceKeystore">proprietary keystore type</a>
implemented by the "SunJCE" provider.</li>
</ul>
</blockquote>
</blockquote>

<hr>
<h1>
<a NAME="AppB"></a>Appendix B: SunJCE Default Keysizes</h1>

<blockquote>The SunJCE provider uses the following default keysizes:
<ul>
<li>
<b>KeyGenerator</b></li>

<ul>
<li>
<b>DES</b>: 56 bits</li>

<P>
<li>
<b>Triple DES</b>: 112 bits</li>

<P>
<li>
<b>Blowfish</b>: 56 bytes</li>

<P>
<li>
<b>HmacMD5</b>: 64 bytes</li>

<P>
<li>
<b>HmacSHA1</b>: 64 bytes</li>
</ul>

<li>
<b>KeyPairGenerator</b></li>

<ul>
<li>
<b>Diffie-Hellman</b>: 1024 bits</li>
</ul>

<li>
<b>AlgorithmParameterGenerator</b></li>

<ul>
<li>
<b>Diffie-Hellman</b>: 1024 bits</li>
</ul>
</ul>
</blockquote>

<hr>
<h1>
<a NAME="AppC"></a>Appendix C: SunJCE Keysize Restrictions</h1>

<blockquote>The SunJCE provider enforces the following restrictions on
the keysize passed to the initialization methods of the following classes:
<ul>
<li>
<b>KeyGenerator</b></li>


<p>Restrictions (by algorithm):
<ul>
<li>
<b>DES</b>: keysize must be equal to <tt>56</tt></li>

<P>
<li>
<b>Triple DES</b>: keysize must be equal to
<tt>112</tt> or <tt>168</tt></li>


<p><B>Note:</B> A keysize of <tt>112</tt> will generate a Triple DES key with
2 intermediate keys, and a keysize of <tt>168</tt> will generate a Triple
DES key with 3 intermediate keys.

<li>
<b>Blowfish</b>: keysize must be a multiple of
<tt>8</tt>, and can only
range from <tt>32</tt> to
<tt>448</tt>, inclusive</li>
</ul>

<li>
<b>KeyPairGenerator</b></li>

<p>Restrictions (by algorithm):
<ul>
<li>
<b>Diffie-Hellman</b>: keysize must be a multiple of
<tt>64</tt>, and can
only range from <tt>512</tt> to
<tt>1024</tt>, inclusive</li>
</ul>

<li>
<b>AlgorithmParameterGenerator</b></li>


<p>Restrictions (by algorithm):
<ul>
<li>
<b>Diffie-Hellman</b>: keysize must be a multiple of
<tt>64</tt>, and can
only range from <tt>512</tt> to
<tt>1024</tt>, inclusive</li>
</ul>
</ul>
</blockquote>

<hr>
<h1>
<a NAME="AppD"></a>Appendix D: Jurisdiction Policy File Format</h1>

<blockquote>JCE 1.2.2 represents its jurisdiction policy files as J2SE-style
policy files with corresponding permission statements. As described in
<a href="http://java.sun.com/products/jdk/1.2/docs/guide/security/PolicyFiles.html">Default
Policy Implementation and Policy File Syntax</a>, a J2SE policy file specifies
what permissions are allowed for code from specified code sources. A permission
represents access to a system resource. In the case of JCE 1.2.2, the "resources"
are cryptography algorithms, and code sources do not need to be specified,
because the cryptographic restrictions apply to all code.
<p>A jurisdiction policy file consists of a very basic "grant entry" containing
one or more "permission entries."
<blockquote>
<pre>grant {
&nbsp;&nbsp;&nbsp; &lt;permission entries>;
};</pre>
</blockquote>
The format of a permission entry in a jurisdiction policy file is:
<blockquote>
<pre>permission &lt;crypto permission class name>[ &lt;alg_name>
&nbsp;&nbsp;&nbsp; [[, &lt;exemption mechanism name>][, &lt;maxKeySize>
&nbsp;&nbsp;&nbsp; [, &lt;AlgorithmParameterSpec class name>,
&nbsp;&nbsp;&nbsp; &lt;parameters for constructing an&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameterSpec object>]]]];</pre>
</blockquote>
A sample jurisdiction policy file that includes restricting the "Blowfish"
algorithm to maximum key sizes of 64 bits is:
<blockquote>
<pre>grant {
&nbsp;&nbsp;&nbsp; permission javax.crypto.CryptoPermission "Blowfish", 64;
&nbsp;&nbsp;&nbsp; . . .;
};</pre>
</blockquote>
A permission entry must begin with the word <tt>permission</tt>. The <tt>&lt;crypto
permission class name></tt> in the template above would actually be a specific
permission class name, such as
<tt>javax.crypto.CryptoPermission</tt>.
A crypto permission class reflects the ability of an application/applet
to use certain algorithms with certain key sizes in certain environments.
There are two crypto permission classes: <tt>CryptoPermission</tt> and
<tt>CryptoAllPermission</tt>.
The special <tt>CryptoAllPermission</tt> class implies all cryptography-related
permissions, that is, it specifies that there are no cryptography-related
restrictions.
<p>The &lt;alg_name>, when utilized, is a quoted string specifying the
standard name (see <a href="#AppA">Appendix A</a>) of a cryptography algorithm,
such as "DES" or "RSA".
<p>The &lt;exemption mechanism name>, when specified, is a quoted string
indicating an exemption mechanism which, if enforced, enables a reduction
in cryptographic restrictions. Exemption mechanism names that can be used
include "KeyRecovery" "KeyEscrow", and "KeyWeakening".
<p>&lt;maxKeySize> is an integer specifying the maximum key size (in bits)
allowed for the specified algorithm.
<p>For some algorithms it may not be sufficient to specify the algorithm
strength in terms of just a key size. For example, in the case of the "RC5"
algorithm, the number of rounds must also be considered. For algorithms
whose strength needs to be expressed as more than a key size, the permission
entry should also specify an AlgorithmParameterSpec class name (such as
<tt>javax.crypto.spec.RC5ParameterSpec</tt>)
and a list of parameters for constructing the specified AlgorithmParameterSpec
object.
<p>Items that appear in a permission entry must appear in the specified
order. An entry is terminated with a semicolon.
<p>Case is unimportant for the identifiers (<tt>grant</tt>, <tt>permission</tt>)
but is significant for the <tt>&lt;crypto permission class name></tt> or
for any string that is passed in as a value.
<p>Note: An "*" can be used as a wildcard for any permission entry option.
For example, an "*" (without the quotes) for an &lt;alg_name> option means
"all algorithms."</blockquote>

<hr>
<h1>
<a NAME="AppE"></a>Appendix E: Sample Programs</h1>

<ul>
<li>
<a NAME="DH2Ex"></a></li>

<h3>
Diffie-Hellman Key Exchange between 2 Parties</h3>

<pre>/*
&nbsp;* Copyright 2002 by Sun Microsystems, Inc.,
&nbsp;* 901 San Antonio Road, USCA12-204, Palo Alto, California, 94303, U.S.A.
&nbsp;* All rights reserved.
&nbsp;*
&nbsp;* This software is the confidential and proprietary information
&nbsp;* of Sun Microsystems, Inc. ("Confidential Information").&nbsp; You
&nbsp;* shall not disclose such Confidential Information and shall use
&nbsp;* it only in accordance with the terms of the license agreement
&nbsp;* you entered into with Sun.
&nbsp;*/

import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

/**
&nbsp;* This program executes the Diffie-Hellman key agreement protocol
&nbsp;* between 2 parties: Alice and Bob.
&nbsp;*
&nbsp;* By default, preconfigured parameters (1024-bit prime modulus and base
&nbsp;* generator used by SKIP) are used.
&nbsp;* If this program is called with the "-gen" option, a new set of
&nbsp;* parameters is created.
&nbsp;*/

public class DHKeyAgreement2 {

&nbsp;&nbsp;&nbsp; private DHKeyAgreement2() {}

&nbsp;&nbsp;&nbsp; public static void main(String argv[]) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String mode = "USE_SKIP_DH_PARAMS";

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add SunJCE to the list of providers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SunJCE jce = new SunJCE();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Security.addProvider(jce);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DHKeyAgreement2 keyAgree = new DHKeyAgreement2();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (argv.length > 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyAgree.usage();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception("Wrong number of command options");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (argv.length == 1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(argv[0].equals("-gen"))) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyAgree.usage();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception("Unrecognized flag: " + argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = "GENERATE_DH_PARAMS";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyAgree.run(mode);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println("Error: " + e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void run(String mode) throws Exception {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DHParameterSpec dhSkipParamSpec;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mode.equals("GENERATE_DH_PARAMS")) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Some central authority creates new DH parameters
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Creating Diffie-Hellman parameters (takes VERY long) ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameterGenerator paramGen
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = AlgorithmParameterGenerator.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paramGen.init(512);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameters params = paramGen.generateParameters();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dhSkipParamSpec = (DHParameterSpec)params.getParameterSpec
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (DHParameterSpec.class);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // use some pre-generated, default DH parameters
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Using SKIP Diffie-Hellman parameters");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dhSkipParamSpec = new DHParameterSpec(skip1024Modulus,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skip1024Base);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Alice creates her own DH key pair, using the DH parameters from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * above
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ALICE: Generate DH keypair ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceKpairGen.initialize(dhSkipParamSpec);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Alice creates and initializes her DH KeyAgreement object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ALICE: Initialization ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceKeyAgree.init(aliceKpair.getPrivate());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Alice encodes her public key, and sends it over to Bob.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Let's turn over to Bob. Bob has received Alice's public key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * in encoded format.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * He instantiates a DH public key from the encoded key material.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyFactory bobKeyFac = KeyFactory.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (alicePubKeyEnc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PublicKey alicePubKey = bobKeyFac.generatePublic(x509KeySpec);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Bob gets the DH parameters associated with Alice's public key.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * He must use the same parameters when he generates his own key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * pair.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DHParameterSpec dhParamSpec = ((DHPublicKey)alicePubKey).getParams();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bob creates his own DH key pair
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("BOB: Generate DH keypair ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobKpairGen.initialize(dhParamSpec);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPair bobKpair = bobKpairGen.generateKeyPair();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bob creates and initializes his DH KeyAgreement object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("BOB: Initialization ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobKeyAgree.init(bobKpair.getPrivate());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bob encodes his public key, and sends it over to Alice.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] bobPubKeyEnc = bobKpair.getPublic().getEncoded();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Alice uses Bob's public key for the first (and only) phase
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * of her version of the DH
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * protocol.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Before she can do so, she has to instanticate a DH public key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * from Bob's encoded key material.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyFactory aliceKeyFac = KeyFactory.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ALICE: Execute PHASE1 ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceKeyAgree.doPhase(bobPubKey, true);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Bob uses Alice's public key for the first (and only) phase
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * of his version of the DH
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * protocol.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("BOB: Execute PHASE1 ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobKeyAgree.doPhase(alicePubKey, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * At this stage, both Alice and Bob have completed the DH key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * agreement protocol.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Both generate the (same) shared secret.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int aliceLen = aliceSharedSecret.length;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] bobSharedSecret = new byte[aliceLen];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bobLen;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // show example of what happens if you
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // provide an output buffer that is too short
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (ShortBufferException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(e.getMessage());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // provide output buffer of required size
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Alice secret: " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toHexString(aliceSharedSecret));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Bob secret: " +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toHexString(bobSharedSecret));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception("Shared secrets differ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Shared secrets are the same");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Now let's return the shared secret as a SecretKey object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * and use it for encryption. First, we generate SecretKeys for the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * "DES" algorithm (based on the raw shared secret data) and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * then we use DES in ECB mode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * as the encryption algorithm. DES in ECB mode does not require any
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * parameters.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Then we use DES in CBC mode, which requires an initialization
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * vector (IV) parameter. In CBC mode, you need to initialize the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Cipher object with an IV, which can be supplied using the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * javax.crypto.spec.IvParameterSpec class. Note that you have to use
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the same IV for encryption and decryption: If you use a different
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * IV for decryption than you used for encryption, decryption will
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * fail.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Note: If you do not specify an IV when you initialize the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Cipher object for encryption, the underlying implementation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * will generate a random one, which you have to retrieve using the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * javax.crypto.Cipher.getParameters() method, which returns an&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * instance of java.security.AlgorithmParameters. You need to transfer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the contents of that object (e.g., in encoded format, obtained via
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the AlgorithmParameters.getEncoded() method) to the party who will
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * do the decryption. When initializing the Cipher for decryption,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the (reinstantiated) AlgorithmParameters object must be passed to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the Cipher.init() method.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Return shared secret as SecretKey object ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bob
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Note: The call to bobKeyAgree.generateSecret above reset the key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // agreement object, so we call doPhase again prior to another
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // generateSecret call
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobKeyAgree.doPhase(alicePubKey, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecretKey bobDesKey = bobKeyAgree.generateSecret("DES");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Alice
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Note: The call to aliceKeyAgree.generateSecret above reset the key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // agreement object, so we call doPhase again prior to another
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // generateSecret call
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceKeyAgree.doPhase(bobPubKey, true);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecretKey aliceDesKey = aliceKeyAgree.generateSecret("DES");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Bob encrypts, using DES in ECB mode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cipher bobCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] cleartext = "This is just an example".getBytes();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] ciphertext = bobCipher.doFinal(cleartext);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Alice decrypts, using DES in ECB mode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cipher aliceCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] recovered = aliceCipher.doFinal(ciphertext);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!java.util.Arrays.equals(cleartext, recovered))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception("DES in CBC mode recovered text is " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "different from cleartext");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("DES in ECB mode recovered text is " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "same as cleartext");&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Bob encrypts, using DES in CBC mode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobCipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cleartext = "This is just an example".getBytes();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ciphertext = bobCipher.doFinal(cleartext);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve the parameter that was used, and transfer it to Alice in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // encoded format
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] encodedParams = bobCipher.getParameters().getEncoded();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Alice decrypts, using DES in CBC mode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Instantiate AlgorithmParameters object from parameter encoding
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // obtained from Bob
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmParameters params = AlgorithmParameters.getInstance("DES");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.init(encodedParams);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceCipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey, params);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recovered = aliceCipher.doFinal(ciphertext);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!java.util.Arrays.equals(cleartext, recovered))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception("DES in CBC mode recovered text is " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "different from cleartext");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("DES in CBC mode recovered text is " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "same as cleartext");&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Converts a byte to hex digit and writes to the supplied buffer
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; private void byte2hex(byte b, StringBuffer buf) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '9', 'A', 'B', 'C', 'D', 'E', 'F' };
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int high = ((b &amp; 0xf0) >> 4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int low = (b &amp; 0x0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.append(hexChars[high]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.append(hexChars[low]);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Converts a byte array to hex string
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; private String toHexString(byte[] block) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuffer buf = new StringBuffer();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len = block.length;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; len; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte2hex(block[i], buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i &lt; len-1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.append(":");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return buf.toString();
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Prints the usage of this test.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; private void usage() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.print("DHKeyAgreement usage: ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println("[-gen]");
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // The 1024 bit Diffie-Hellman modulus values used by SKIP
&nbsp;&nbsp;&nbsp; private static final byte skip1024ModulusBytes[] = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7
&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; // The SKIP 1024 bit modulus
&nbsp;&nbsp;&nbsp; private static final BigInteger skip1024Modulus
&nbsp;&nbsp;&nbsp; = new BigInteger(1, skip1024ModulusBytes);

&nbsp;&nbsp;&nbsp; // The base used with the SKIP 1024 bit modulus
&nbsp;&nbsp;&nbsp; private static final BigInteger skip1024Base = BigInteger.valueOf(2);
}</pre>

<hr>
<li>
<a NAME="DH3Ex"></a></li>

<h3>
Diffie-Hellman Key Exchange between 3 Parties</h3>

<pre>/*
&nbsp;* Copyright 2002 by Sun Microsystems, Inc.,
&nbsp;* 901 San Antonio Road, USCA12-204, Palo Alto, California, 94303, U.S.A.
&nbsp;* All rights reserved.
&nbsp;*
&nbsp;* This software is the confidential and proprietary information
&nbsp;* of Sun Microsystems, Inc. ("Confidential Information").&nbsp; You
&nbsp;* shall not disclose such Confidential Information and shall use
&nbsp;* it only in accordance with the terms of the license agreement
&nbsp;* you entered into with Sun.
&nbsp;*/

import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

/**
&nbsp;* This program executes the Diffie-Hellman key agreement protocol
&nbsp;* between 3 parties: Alice, Bob, and Carol.
&nbsp;*
&nbsp;* We use the same 1024-bit prime modulus and base generator that are&nbsp;
&nbsp;* used by SKIP.
&nbsp;*/

public class DHKeyAgreement3 {

&nbsp;&nbsp;&nbsp; private DHKeyAgreement3() {}

&nbsp;&nbsp;&nbsp; public static void main(String argv[]) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Add SunJCE to the list of providers
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SunJCE jce = new SunJCE();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Security.addProvider(jce);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DHKeyAgreement3 keyAgree = new DHKeyAgreement3();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyAgree.run();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println("Error: " + e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.exit(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void run() throws Exception {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DHParameterSpec dhSkipParamSpec;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Using SKIP Diffie-Hellman parameters");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dhSkipParamSpec = new DHParameterSpec(skip1024Modulus, skip1024Base);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Alice creates her own DH key pair
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ALICE: Generate DH keypair ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceKpairGen.initialize(dhSkipParamSpec);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bob creates his own DH key pair
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("BOB: Generate DH keypair ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobKpairGen.initialize(dhSkipParamSpec);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPair bobKpair = bobKpairGen.generateKeyPair();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Carol creates her own DH key pair
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("CAROL: Generate DH keypair ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPairGenerator carolKpairGen = KeyPairGenerator.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; carolKpairGen.initialize(dhSkipParamSpec);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyPair carolKpair = carolKpairGen.generateKeyPair();


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Alice initialize
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("ALICE: Initialize ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceKeyAgree.init(aliceKpair.getPrivate());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bob initialize
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("BOB: Initialize ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobKeyAgree.init(bobKpair.getPrivate());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Carol initialize
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("CAROL: Initialize ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyAgreement carolKeyAgree = KeyAgreement.getInstance("DH");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; carolKeyAgree.init(carolKpair.getPrivate());


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Alice uses Carol's public key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key ac = aliceKeyAgree.doPhase(carolKpair.getPublic(), false);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bob uses Alice's public key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key ba = bobKeyAgree.doPhase(aliceKpair.getPublic(), false);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Carol uses Bob's public key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key cb = carolKeyAgree.doPhase(bobKpair.getPublic(), false);


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Alice uses Carol's result from above
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aliceKeyAgree.doPhase(cb, true);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bob uses Alice's result from above
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bobKeyAgree.doPhase(ac, true);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Carol uses Bob's result from above
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; carolKeyAgree.doPhase(ba, true);


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Alice, Bob and Carol compute their secrets
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Alice secret: " + toHexString(aliceSharedSecret));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] bobSharedSecret = bobKeyAgree.generateSecret();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Bob secret: " + toHexString(bobSharedSecret));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] carolSharedSecret = carolKeyAgree.generateSecret();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Carol secret: " + toHexString(carolSharedSecret));


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Compare Alice and Bob
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception("Alice and Bob differ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Alice and Bob are the same");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Compare Bob and Carol
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!java.util.Arrays.equals(bobSharedSecret, carolSharedSecret))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception("Bob and Carol differ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Bob and Carol are the same");
&nbsp;&nbsp;&nbsp; }


&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Converts a byte to hex digit and writes to the supplied buffer
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; private void byte2hex(byte b, StringBuffer buf) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '9', 'A', 'B', 'C', 'D', 'E', 'F' };
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int high = ((b &amp; 0xf0) >> 4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int low = (b &amp; 0x0f);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.append(hexChars[high]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.append(hexChars[low]);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Converts a byte array to hex string
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; private String toHexString(byte[] block) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuffer buf = new StringBuffer();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len = block.length;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; len; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte2hex(block[i], buf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i &lt; len-1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.append(":");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return buf.toString();
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Prints the usage of this test.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; private void usage() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.print("DHKeyAgreement usage: ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println("[-gen]");
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // The 1024 bit Diffie-Hellman modulus values used by SKIP
&nbsp;&nbsp;&nbsp; private static final byte skip1024ModulusBytes[] = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7
&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; // The SKIP 1024 bit modulus
&nbsp;&nbsp;&nbsp; private static final BigInteger skip1024Modulus
&nbsp;&nbsp;&nbsp; = new BigInteger(1, skip1024ModulusBytes);

&nbsp;&nbsp;&nbsp; // The base used with the SKIP 1024 bit modulus
&nbsp;&nbsp;&nbsp; private static final BigInteger skip1024Base = BigInteger.valueOf(2);
}</pre>

<hr>
<li>
<a NAME="BlowKeyEx"></a></li>

<h3>
Blowfish Example</h3>

<pre>/*
&nbsp;* Copyright 2002 by Sun Microsystems, Inc.,
&nbsp;* 901 San Antonio Road, USCA12-204, Palo Alto, California, 94303, U.S.A.
&nbsp;* All rights reserved.
&nbsp;*
&nbsp;* This software is the confidential and proprietary information
&nbsp;* of Sun Microsystems, Inc. ("Confidential Information").&nbsp; You
&nbsp;* shall not disclose such Confidential Information and shall use
&nbsp;* it only in accordance with the terms of the license agreement
&nbsp;* you entered into with Sun.
&nbsp;*/

import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.*;

/**
&nbsp;* This program generates a Blowfish key, retrieves its raw bytes, and&nbsp;
&nbsp;* then reinstantiates a Blowfish key from the key bytes.
&nbsp;* The reinstantiated key is used to initialize a Blowfish cipher for
&nbsp;* encryption.
&nbsp;*/

public class BlowfishKey {

&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws Exception {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Install SunJCE provider
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Provider sunJce = new com.sun.crypto.provider.SunJCE();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Security.addProvider(sunJce);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyGenerator kgen = KeyGenerator.getInstance("Blowfish");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecretKey skey = kgen.generateKey();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] raw = skey.getEncoded();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecretKeySpec skeySpec = new SecretKeySpec(raw, "Blowfish");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cipher cipher = Cipher.getInstance("Blowfish");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] encrypted =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cipher.doFinal("This is just an example".getBytes());
&nbsp;&nbsp;&nbsp; }
}</pre>

<hr>
<li>
<a NAME="HmacEx"></a></li>

<h3>
HMAC-MD5 Example</h3>

<pre>/*
&nbsp;* Copyright 2002 by Sun Microsystems, Inc.,
&nbsp;* 901 San Antonio Road, USCA12-204, Palo Alto, California, 94303, U.S.A.
&nbsp;* All rights reserved.
&nbsp;*
&nbsp;* This software is the confidential and proprietary information
&nbsp;* of Sun Microsystems, Inc. ("Confidential Information").&nbsp; You
&nbsp;* shall not disclose such Confidential Information and shall use
&nbsp;* it only in accordance with the terms of the license agreement
&nbsp;* you entered into with Sun.
&nbsp;*/

import java.security.*;
import javax.crypto.*;

/**
&nbsp;* This program demonstrates how to generate a secret-key object for
&nbsp;* HMAC-MD5, and initialize an HMAC-MD5 object with it.
&nbsp;*/

public class initMac {

&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws Exception {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Install SunJCE provider
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Provider sunJce = new com.sun.crypto.provider.SunJCE();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Security.addProvider(sunJce);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Generate secret key for HMAC-MD5
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeyGenerator kg = KeyGenerator.getInstance("HmacMD5");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecretKey sk = kg.generateKey();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get instance of Mac object implementing HMAC-MD5, and&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // initialize it with the above secret key
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mac mac = Mac.getInstance("HmacMD5");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mac.init(sk);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] result = mac.doFinal("Hi There".getBytes());
&nbsp;&nbsp;&nbsp; }
}</pre>
</ul>
<!-- Body text ends here --><!-- ============================================================== -->
<hr SIZE=3 NOSHADE>
<table BORDER=0 WIDTH="100%">
<tr VALIGN=TOP>
<td><font size=-2><a href="../relnotes/SMICopyright.html">Copyright &copy;</a>
 2002 <a href="http://www.sun.com/">Sun Microsystems, Inc.</a> All
Rights Reserved.</font>
<P>
<font size=-1>Please send comments to: <a href="mailto:java-security@java.sun.com">java-security@java.sun.com</a>.&nbsp;</font></td>

<td ALIGN=RIGHT><img SRC="../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 height=30 width=64>
<br><i><font size=+1>Java Software</font></i></td>
</tr>
</table>
<!-- Created: Wed Jan 20 16:30:48 PST 1999 -->
<!-- hhmts start -->Last modified: Fri May 3 2002<!-- hhmts end -->
</body>
</html>






















